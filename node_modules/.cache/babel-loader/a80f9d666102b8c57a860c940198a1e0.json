{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { PositionNode } from './PositionNode.js';\nimport { NormalNode } from './NormalNode.js';\n\nfunction ReflectNode(scope) {\n  TempNode.call(this, 'v3');\n  this.scope = scope || ReflectNode.CUBE;\n}\n\nReflectNode.CUBE = 'cube';\nReflectNode.SPHERE = 'sphere';\nReflectNode.VECTOR = 'vector';\nReflectNode.prototype = Object.create(TempNode.prototype);\nReflectNode.prototype.constructor = ReflectNode;\nReflectNode.prototype.nodeType = 'Reflect';\n\nReflectNode.prototype.getUnique = function (builder) {\n  return !builder.context.viewNormal;\n};\n\nReflectNode.prototype.getType = function ()\n/* builder */\n{\n  switch (this.scope) {\n    case ReflectNode.SPHERE:\n      return 'v2';\n  }\n\n  return this.type;\n};\n\nReflectNode.prototype.generate = function (builder, output) {\n  var isUnique = this.getUnique(builder);\n\n  if (builder.isShader('fragment')) {\n    var result;\n\n    switch (this.scope) {\n      case ReflectNode.VECTOR:\n        var viewNormalNode = new NormalNode(NormalNode.VIEW);\n        var roughnessNode = builder.context.roughness;\n        var viewNormal = viewNormalNode.build(builder, 'v3');\n        var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n        var method = \"reflect( -normalize( \".concat(viewPosition, \" ), \").concat(viewNormal, \" )\");\n\n        if (roughness) {\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n          method = \"normalize( mix( \".concat(method, \", \").concat(viewNormal, \", \").concat(roughness, \" * \").concat(roughness, \" ) )\");\n        }\n\n        var code = \"inverseTransformDirection( \".concat(method, \", viewMatrix )\");\n\n        if (isUnique) {\n          builder.addNodeCode(\"vec3 reflectVec = \".concat(code, \";\"));\n          result = 'reflectVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.CUBE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n\n        if (isUnique) {\n          builder.addNodeCode(\"vec3 reflectCubeVec = \".concat(code, \";\"));\n          result = 'reflectCubeVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.SPHERE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n\n        if (isUnique) {\n          builder.addNodeCode(\"vec2 reflectSphereVec = \".concat(code, \";\"));\n          result = 'reflectSphereVec';\n        } else {\n          result = code;\n        }\n\n        break;\n    }\n\n    return builder.format(result, this.getType(builder), output);\n  } else {\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.type, output);\n  }\n};\n\nReflectNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.scope = this.scope;\n  }\n\n  return data;\n};\n\nexport { ReflectNode };","map":{"version":3,"names":["TempNode","PositionNode","NormalNode","ReflectNode","scope","call","CUBE","SPHERE","VECTOR","prototype","Object","create","constructor","nodeType","getUnique","builder","context","viewNormal","getType","type","generate","output","isUnique","isShader","result","viewNormalNode","VIEW","roughnessNode","roughness","build","viewPosition","undefined","method","code","addNodeCode","reflectVec","format","console","warn","shader","toJSON","meta","data","getJSONNode","createJSONNode"],"sources":["/Users/98yaroslavgorban/Desktop/gltfjsx-forked/node_modules/three-stdlib/nodes/accessors/ReflectNode.js"],"sourcesContent":["import { TempNode } from '../core/TempNode.js';\nimport { PositionNode } from './PositionNode.js';\nimport { NormalNode } from './NormalNode.js';\n\nfunction ReflectNode(scope) {\n  TempNode.call(this, 'v3');\n  this.scope = scope || ReflectNode.CUBE;\n}\n\nReflectNode.CUBE = 'cube';\nReflectNode.SPHERE = 'sphere';\nReflectNode.VECTOR = 'vector';\nReflectNode.prototype = Object.create(TempNode.prototype);\nReflectNode.prototype.constructor = ReflectNode;\nReflectNode.prototype.nodeType = 'Reflect';\n\nReflectNode.prototype.getUnique = function (builder) {\n  return !builder.context.viewNormal;\n};\n\nReflectNode.prototype.getType = function ()\n/* builder */\n{\n  switch (this.scope) {\n    case ReflectNode.SPHERE:\n      return 'v2';\n  }\n\n  return this.type;\n};\n\nReflectNode.prototype.generate = function (builder, output) {\n  var isUnique = this.getUnique(builder);\n\n  if (builder.isShader('fragment')) {\n    var result;\n\n    switch (this.scope) {\n      case ReflectNode.VECTOR:\n        var viewNormalNode = new NormalNode(NormalNode.VIEW);\n        var roughnessNode = builder.context.roughness;\n        var viewNormal = viewNormalNode.build(builder, 'v3');\n        var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n        var method = `reflect( -normalize( ${viewPosition} ), ${viewNormal} )`;\n\n        if (roughness) {\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n          method = `normalize( mix( ${method}, ${viewNormal}, ${roughness} * ${roughness} ) )`;\n        }\n\n        var code = `inverseTransformDirection( ${method}, viewMatrix )`;\n\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectVec = ${code};`);\n          result = 'reflectVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.CUBE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectCubeVec = ${code};`);\n          result = 'reflectCubeVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.SPHERE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n\n        if (isUnique) {\n          builder.addNodeCode(`vec2 reflectSphereVec = ${code};`);\n          result = 'reflectSphereVec';\n        } else {\n          result = code;\n        }\n\n        break;\n    }\n\n    return builder.format(result, this.getType(builder), output);\n  } else {\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.type, output);\n  }\n};\n\nReflectNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.scope = this.scope;\n  }\n\n  return data;\n};\n\nexport { ReflectNode };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}