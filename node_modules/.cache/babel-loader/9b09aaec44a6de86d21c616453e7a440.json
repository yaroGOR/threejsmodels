{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { InputNode } from '../core/InputNode.js';\nimport { PositionNode } from '../accessors/PositionNode.js';\nimport { OperatorNode } from '../math/OperatorNode.js';\nimport { TextureNode } from './TextureNode.js';\nimport { Matrix4Node } from './Matrix4Node.js';\n\nfunction ReflectorNode(mirror) {\n  TempNode.call(this, 'v4');\n  if (mirror) this.setMirror(mirror);\n}\n\nReflectorNode.prototype = Object.create(TempNode.prototype);\nReflectorNode.prototype.constructor = ReflectorNode;\nReflectorNode.prototype.nodeType = 'Reflector';\n\nReflectorNode.prototype.setMirror = function (mirror) {\n  this.mirror = mirror;\n  this.textureMatrix = new Matrix4Node(this.mirror.material.uniforms.textureMatrix.value);\n  this.localPosition = new PositionNode(PositionNode.LOCAL);\n  this.uv = new OperatorNode(this.textureMatrix, this.localPosition, OperatorNode.MUL);\n  this.uvResult = new OperatorNode(null, this.uv, OperatorNode.ADD);\n  this.texture = new TextureNode(this.mirror.material.uniforms.tDiffuse.value, this.uv, null, true);\n};\n\nReflectorNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    this.uvResult.a = this.offset;\n    this.texture.uv = this.offset ? this.uvResult : this.uv;\n\n    if (output === 'sampler2D') {\n      return this.texture.build(builder, output);\n    }\n\n    return builder.format(this.texture.build(builder, this.type), this.type, output);\n  } else {\n    console.warn('THREE.ReflectorNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.type, output);\n  }\n};\n\nReflectorNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  this.scope.mirror = source.mirror;\n  return this;\n};\n\nReflectorNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.mirror = this.mirror.uuid;\n    if (this.offset) data.offset = this.offset.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { ReflectorNode };","map":{"version":3,"names":["TempNode","InputNode","PositionNode","OperatorNode","TextureNode","Matrix4Node","ReflectorNode","mirror","call","setMirror","prototype","Object","create","constructor","nodeType","textureMatrix","material","uniforms","value","localPosition","LOCAL","uv","MUL","uvResult","ADD","texture","tDiffuse","generate","builder","output","isShader","a","offset","build","format","type","console","warn","shader","copy","source","scope","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"sources":["/Users/98yaroslavgorban/Desktop/gltfjsx-forked/node_modules/three-stdlib/nodes/inputs/ReflectorNode.js"],"sourcesContent":["import { TempNode } from '../core/TempNode.js';\nimport { InputNode } from '../core/InputNode.js';\nimport { PositionNode } from '../accessors/PositionNode.js';\nimport { OperatorNode } from '../math/OperatorNode.js';\nimport { TextureNode } from './TextureNode.js';\nimport { Matrix4Node } from './Matrix4Node.js';\n\nfunction ReflectorNode(mirror) {\n  TempNode.call(this, 'v4');\n  if (mirror) this.setMirror(mirror);\n}\n\nReflectorNode.prototype = Object.create(TempNode.prototype);\nReflectorNode.prototype.constructor = ReflectorNode;\nReflectorNode.prototype.nodeType = 'Reflector';\n\nReflectorNode.prototype.setMirror = function (mirror) {\n  this.mirror = mirror;\n  this.textureMatrix = new Matrix4Node(this.mirror.material.uniforms.textureMatrix.value);\n  this.localPosition = new PositionNode(PositionNode.LOCAL);\n  this.uv = new OperatorNode(this.textureMatrix, this.localPosition, OperatorNode.MUL);\n  this.uvResult = new OperatorNode(null, this.uv, OperatorNode.ADD);\n  this.texture = new TextureNode(this.mirror.material.uniforms.tDiffuse.value, this.uv, null, true);\n};\n\nReflectorNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    this.uvResult.a = this.offset;\n    this.texture.uv = this.offset ? this.uvResult : this.uv;\n\n    if (output === 'sampler2D') {\n      return this.texture.build(builder, output);\n    }\n\n    return builder.format(this.texture.build(builder, this.type), this.type, output);\n  } else {\n    console.warn('THREE.ReflectorNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.type, output);\n  }\n};\n\nReflectorNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  this.scope.mirror = source.mirror;\n  return this;\n};\n\nReflectorNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.mirror = this.mirror.uuid;\n    if (this.offset) data.offset = this.offset.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { ReflectorNode };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}