{"ast":null,"code":"import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset } from \"../../cst/cst\";\nimport { has, isUndefined, keys, NOOP } from \"../../../utils/utils\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults } from \"../../cst/cst_visitor\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * This trait is responsible for the CST building logic.\n */\n\nvar TreeBuilder =\n/** @class */\nfunction () {\n  function TreeBuilder() {}\n\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.CST_STACK = []; // outputCst is no longer exposed/defined in the pubic API\n\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = NOOP;\n      this.cstFinallyStateUpdate = NOOP;\n      this.cstPostTerminal = NOOP;\n      this.cstPostNonTerminal = NOOP;\n      this.cstPostRule = NOOP;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = NOOP;\n        this.setNodeLocationFromNode = NOOP;\n        this.cstPostRule = NOOP;\n        this.setInitialNodeLocation = NOOP;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n      }\n    }\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n        * @param cstNode\n     */\n\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n    var cstNode = {\n      name: fullRuleName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.CST_STACK.pop();\n  };\n\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    } // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  };\n\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    } // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  };\n\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n\n    return this.baseCstVisitorConstructor;\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n\n  return TreeBuilder;\n}();\n\nexport { TreeBuilder };","map":{"version":3,"mappings":"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","names":["addNoneTerminalToCst","addTerminalToCst","setNodeLocationFull","setNodeLocationOnlyOffset","has","isUndefined","keys","NOOP","createBaseSemanticVisitorConstructor","createBaseVisitorConstructorWithDefaults","DEFAULT_PARSER_CONFIG","TreeBuilder","config","CST_STACK","outputCst","nodeLocationTracking","cstInvocationStateUpdate","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","cstPostRule","test","recoveryEnabled","setNodeLocationFromToken","setNodeLocationFromNode","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","Error","cstNode","location","startOffset","NaN","endOffset","LA","startLine","startColumn","endLine","endColumn","nextToken","fullRuleName","shortName","name","children","push","pop","ruleCstNode","prevToken","loc","key","consumedToken","rootCst","length","ruleCstResult","ruleName","preCstNode","baseCstVisitorConstructor","newBaseCstVisitorConstructor","className","gastProductionsCache","baseCstVisitorWithDefaultsConstructor","newConstructor","getBaseCstVisitorConstructor","ruleStack","RULE_STACK","occurrenceStack","RULE_OCCURRENCE_STACK"],"sourceRoot":"","sources":["../../../../../src/parse/parser/traits/tree_builder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}