{"ast":null,"code":"import { Mesh, Color, Vector3, Plane, Matrix4, Vector4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\n\nvar ReflectorForSSRPass = function ReflectorForSSRPass(geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'ReflectorForSSRPass';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n  var useDepthTexture = options.useDepthTexture;\n  var yAxis = new Vector3(0, 1, 0);\n  var vecTemp0 = new Vector3();\n  var vecTemp1 = new Vector3(); //\n\n  scope.needsUpdate = false;\n  scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n  scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n  scope._isDistanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.isDistanceAttenuation;\n  Object.defineProperty(scope, 'isDistanceAttenuation', {\n    get: function get() {\n      return scope._isDistanceAttenuation;\n    },\n    set: function set(val) {\n      if (scope._isDistanceAttenuation === val) return;\n      scope._isDistanceAttenuation = val;\n      scope.material.defines.isDistanceAttenuation = val;\n      scope.material.needsUpdate = true;\n    }\n  });\n  scope._isFresnel = ReflectorForSSRPass.ReflectorShader.defines.isFresnel;\n  Object.defineProperty(scope, 'isFresnel', {\n    get: function get() {\n      return scope._isFresnel;\n    },\n    set: function set(val) {\n      if (scope._isFresnel === val) return;\n      scope._isFresnel = val;\n      scope.material.defines.isFresnel = val;\n      scope.material.needsUpdate = true;\n    }\n  });\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n\n  if (useDepthTexture) {\n    var depthTexture = new DepthTexture();\n    depthTexture.type = UnsignedShortType;\n    depthTexture.minFilter = NearestFilter;\n    depthTexture.maxFilter = NearestFilter;\n  }\n\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat,\n    depthTexture: useDepthTexture ? depthTexture : null\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new ShaderMaterial({\n    transparent: useDepthTexture,\n    defines: Object.assign({\n      useDepthTexture: useDepthTexture\n    }, ReflectorForSSRPass.ReflectorShader.defines),\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n\n  if (useDepthTexture) {\n    material.uniforms['tDepth'].value = renderTarget.depthTexture;\n  }\n\n  this.material = material;\n\n  this.doRender = function (renderer, scene, camera) {\n    material.uniforms['maxDistance'].value = scope.maxDistance * (camera.position.length() / camera.position.y); ///todo: Temporary hack,\n    // need precise calculation like this https://github.com/mrdoob/three.js/pull/20156/commits/8181946068e386d14a283cbd4f8877bc7ae066d3 ,\n    // after fully understand http://www.terathon.com/lengyel/Lengyel-Oblique.pdf .\n\n    material.uniforms['opacity'].value = scope.opacity;\n    vecTemp0.copy(camera.position).normalize();\n    vecTemp1.copy(vecTemp0).reflect(yAxis);\n    material.uniforms['fresnel'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; ///todo: Also need to use glsl viewPosition and viewNormal per pixel.\n    // console.log(material.uniforms['fresnel'].value)\n\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    } // scope.visible = true;\n\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nReflectorForSSRPass.prototype = Object.create(Mesh.prototype);\nReflectorForSSRPass.prototype.constructor = ReflectorForSSRPass;\nReflectorForSSRPass.ReflectorShader = {\n  ///todo: Will conflict with ReflectorForSSRPass.js?\n  defines: {\n    isDistanceAttenuation: true,\n    isFresnel: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnel: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: \"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tuniform sampler2D tDepth;\\n\\t\\tuniform float maxDistance;\\n\\t\\tuniform float opacity;\\n\\t\\tuniform float fresnel;\\n\\t\\tvarying vec4 vUv;\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\t\\t}\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\t\\t}\\n\\t\\tvoid main() {\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\t#ifdef useDepthTexture\\n\\t\\t\\t\\tfloat op=opacity;\\n\\t\\t\\t\\tfloat depth = texture2DProj( tDepth, vUv ).r;\\n\\t\\t\\t\\tif(depth>maxDistance) discard;\\n\\t\\t\\t\\t#ifdef isDistanceAttenuation\\n\\t\\t\\t\\t\\tfloat ratio=1.-(depth/maxDistance);\\n\\t\\t\\t\\t\\tfloat attenuation=ratio*ratio;\\n\\t\\t\\t\\t\\top=opacity*attenuation;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#ifdef isFresnel\\n\\t\\t\\t\\t\\top*=fresnel;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\"\n};\nexport { ReflectorForSSRPass };","map":{"version":3,"names":["Mesh","Color","Vector3","Plane","Matrix4","Vector4","PerspectiveCamera","DepthTexture","UnsignedShortType","NearestFilter","WebGLRenderTarget","MathUtils","ShaderMaterial","UniformsUtils","LinearFilter","RGBFormat","ReflectorForSSRPass","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","value","opacity","_isDistanceAttenuation","defines","isDistanceAttenuation","Object","defineProperty","get","set","val","material","_isFresnel","isFresnel","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","depthTexture","minFilter","maxFilter","parameters","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","transparent","assign","clone","fragmentShader","vertexShader","doRender","renderer","scene","camera","position","length","y","copy","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","create","constructor","tDiffuse","tDepth","fresnel","join"],"sources":["/Users/98yaroslavgorban/Desktop/gltfjsx-forked/node_modules/three-stdlib/objects/ReflectorForSSRPass.js"],"sourcesContent":["import { Mesh, Color, Vector3, Plane, Matrix4, Vector4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\n\nvar ReflectorForSSRPass = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'ReflectorForSSRPass';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n  var useDepthTexture = options.useDepthTexture;\n  var yAxis = new Vector3(0, 1, 0);\n  var vecTemp0 = new Vector3();\n  var vecTemp1 = new Vector3(); //\n\n  scope.needsUpdate = false;\n  scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n  scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n  scope._isDistanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.isDistanceAttenuation;\n  Object.defineProperty(scope, 'isDistanceAttenuation', {\n    get() {\n      return scope._isDistanceAttenuation;\n    },\n\n    set(val) {\n      if (scope._isDistanceAttenuation === val) return;\n      scope._isDistanceAttenuation = val;\n      scope.material.defines.isDistanceAttenuation = val;\n      scope.material.needsUpdate = true;\n    }\n\n  });\n  scope._isFresnel = ReflectorForSSRPass.ReflectorShader.defines.isFresnel;\n  Object.defineProperty(scope, 'isFresnel', {\n    get() {\n      return scope._isFresnel;\n    },\n\n    set(val) {\n      if (scope._isFresnel === val) return;\n      scope._isFresnel = val;\n      scope.material.defines.isFresnel = val;\n      scope.material.needsUpdate = true;\n    }\n\n  });\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n\n  if (useDepthTexture) {\n    var depthTexture = new DepthTexture();\n    depthTexture.type = UnsignedShortType;\n    depthTexture.minFilter = NearestFilter;\n    depthTexture.maxFilter = NearestFilter;\n  }\n\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat,\n    depthTexture: useDepthTexture ? depthTexture : null\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new ShaderMaterial({\n    transparent: useDepthTexture,\n    defines: Object.assign({\n      useDepthTexture: useDepthTexture\n    }, ReflectorForSSRPass.ReflectorShader.defines),\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n\n  if (useDepthTexture) {\n    material.uniforms['tDepth'].value = renderTarget.depthTexture;\n  }\n\n  this.material = material;\n\n  this.doRender = function (renderer, scene, camera) {\n    material.uniforms['maxDistance'].value = scope.maxDistance * (camera.position.length() / camera.position.y); ///todo: Temporary hack,\n    // need precise calculation like this https://github.com/mrdoob/three.js/pull/20156/commits/8181946068e386d14a283cbd4f8877bc7ae066d3 ,\n    // after fully understand http://www.terathon.com/lengyel/Lengyel-Oblique.pdf .\n\n    material.uniforms['opacity'].value = scope.opacity;\n    vecTemp0.copy(camera.position).normalize();\n    vecTemp1.copy(vecTemp0).reflect(yAxis);\n    material.uniforms['fresnel'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; ///todo: Also need to use glsl viewPosition and viewNormal per pixel.\n    // console.log(material.uniforms['fresnel'].value)\n\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    } // scope.visible = true;\n\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nReflectorForSSRPass.prototype = Object.create(Mesh.prototype);\nReflectorForSSRPass.prototype.constructor = ReflectorForSSRPass;\nReflectorForSSRPass.ReflectorShader = {\n  ///todo: Will conflict with ReflectorForSSRPass.js?\n  defines: {\n    isDistanceAttenuation: true,\n    isFresnel: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnel: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnel;\n\t\tvarying vec4 vUv;\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tfloat op=opacity;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tif(depth>maxDistance) discard;\n\t\t\t\t#ifdef isDistanceAttenuation\n\t\t\t\t\tfloat ratio=1.-(depth/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef isFresnel\n\t\t\t\t\top*=fresnel;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\n\nexport { ReflectorForSSRPass };\n"],"mappings":"AAAA,SAASA,IAAT,EAAeC,KAAf,EAAsBC,OAAtB,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA+CC,OAA/C,EAAwDC,iBAAxD,EAA2EC,YAA3E,EAAyFC,iBAAzF,EAA4GC,aAA5G,EAA2HC,iBAA3H,EAA8IC,SAA9I,EAAyJC,cAAzJ,EAAyKC,aAAzK,EAAwLC,YAAxL,EAAsMC,SAAtM,QAAuN,OAAvN;;AAEA,IAAIC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAUC,QAAV,EAAoBC,OAApB,EAA6B;EACrDlB,IAAI,CAACmB,IAAL,CAAU,IAAV,EAAgBF,QAAhB;EACA,KAAKG,IAAL,GAAY,qBAAZ;EACA,IAAIC,KAAK,GAAG,IAAZ;EACAH,OAAO,GAAGA,OAAO,IAAI,EAArB;EACA,IAAII,KAAK,GAAGJ,OAAO,CAACI,KAAR,KAAkBC,SAAlB,GAA8B,IAAItB,KAAJ,CAAUiB,OAAO,CAACI,KAAlB,CAA9B,GAAyD,IAAIrB,KAAJ,CAAU,QAAV,CAArE;EACA,IAAIuB,YAAY,GAAGN,OAAO,CAACM,YAAR,IAAwB,GAA3C;EACA,IAAIC,aAAa,GAAGP,OAAO,CAACO,aAAR,IAAyB,GAA7C;EACA,IAAIC,QAAQ,GAAGR,OAAO,CAACQ,QAAR,IAAoB,CAAnC;EACA,IAAIC,MAAM,GAAGT,OAAO,CAACS,MAAR,IAAkBX,mBAAmB,CAACY,eAAnD;EACA,IAAIC,eAAe,GAAGX,OAAO,CAACW,eAA9B;EACA,IAAIC,KAAK,GAAG,IAAI5B,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAZ;EACA,IAAI6B,QAAQ,GAAG,IAAI7B,OAAJ,EAAf;EACA,IAAI8B,QAAQ,GAAG,IAAI9B,OAAJ,EAAf,CAbqD,CAavB;;EAE9BmB,KAAK,CAACY,WAAN,GAAoB,KAApB;EACAZ,KAAK,CAACa,WAAN,GAAoBlB,mBAAmB,CAACY,eAApB,CAAoCO,QAApC,CAA6CD,WAA7C,CAAyDE,KAA7E;EACAf,KAAK,CAACgB,OAAN,GAAgBrB,mBAAmB,CAACY,eAApB,CAAoCO,QAApC,CAA6CE,OAA7C,CAAqDD,KAArE;EACAf,KAAK,CAACiB,sBAAN,GAA+BtB,mBAAmB,CAACY,eAApB,CAAoCW,OAApC,CAA4CC,qBAA3E;EACAC,MAAM,CAACC,cAAP,CAAsBrB,KAAtB,EAA6B,uBAA7B,EAAsD;IACpDsB,GADoD,iBAC9C;MACJ,OAAOtB,KAAK,CAACiB,sBAAb;IACD,CAHmD;IAKpDM,GALoD,eAKhDC,GALgD,EAK3C;MACP,IAAIxB,KAAK,CAACiB,sBAAN,KAAiCO,GAArC,EAA0C;MAC1CxB,KAAK,CAACiB,sBAAN,GAA+BO,GAA/B;MACAxB,KAAK,CAACyB,QAAN,CAAeP,OAAf,CAAuBC,qBAAvB,GAA+CK,GAA/C;MACAxB,KAAK,CAACyB,QAAN,CAAeb,WAAf,GAA6B,IAA7B;IACD;EAVmD,CAAtD;EAaAZ,KAAK,CAAC0B,UAAN,GAAmB/B,mBAAmB,CAACY,eAApB,CAAoCW,OAApC,CAA4CS,SAA/D;EACAP,MAAM,CAACC,cAAP,CAAsBrB,KAAtB,EAA6B,WAA7B,EAA0C;IACxCsB,GADwC,iBAClC;MACJ,OAAOtB,KAAK,CAAC0B,UAAb;IACD,CAHuC;IAKxCH,GALwC,eAKpCC,GALoC,EAK/B;MACP,IAAIxB,KAAK,CAAC0B,UAAN,KAAqBF,GAAzB,EAA8B;MAC9BxB,KAAK,CAAC0B,UAAN,GAAmBF,GAAnB;MACAxB,KAAK,CAACyB,QAAN,CAAeP,OAAf,CAAuBS,SAAvB,GAAmCH,GAAnC;MACAxB,KAAK,CAACyB,QAAN,CAAeb,WAAf,GAA6B,IAA7B;IACD;EAVuC,CAA1C;EAaA,IAAIgB,cAAc,GAAG,IAAI9C,KAAJ,EAArB;EACA,IAAI+C,MAAM,GAAG,IAAIhD,OAAJ,EAAb;EACA,IAAIiD,sBAAsB,GAAG,IAAIjD,OAAJ,EAA7B;EACA,IAAIkD,mBAAmB,GAAG,IAAIlD,OAAJ,EAA1B;EACA,IAAImD,cAAc,GAAG,IAAIjD,OAAJ,EAArB;EACA,IAAIkD,cAAc,GAAG,IAAIpD,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAC,CAAnB,CAArB;EACA,IAAIqD,SAAS,GAAG,IAAIlD,OAAJ,EAAhB;EACA,IAAImD,IAAI,GAAG,IAAItD,OAAJ,EAAX;EACA,IAAIuD,MAAM,GAAG,IAAIvD,OAAJ,EAAb;EACA,IAAIwD,CAAC,GAAG,IAAIrD,OAAJ,EAAR;EACA,IAAIsD,aAAa,GAAG,IAAIvD,OAAJ,EAApB;EACA,IAAIwD,aAAa,GAAG,IAAItD,iBAAJ,EAApB;;EAEA,IAAIuB,eAAJ,EAAqB;IACnB,IAAIgC,YAAY,GAAG,IAAItD,YAAJ,EAAnB;IACAsD,YAAY,CAACzC,IAAb,GAAoBZ,iBAApB;IACAqD,YAAY,CAACC,SAAb,GAAyBrD,aAAzB;IACAoD,YAAY,CAACE,SAAb,GAAyBtD,aAAzB;EACD;;EAED,IAAIuD,UAAU,GAAG;IACfF,SAAS,EAAEhD,YADI;IAEfmD,SAAS,EAAEnD,YAFI;IAGfoD,MAAM,EAAEnD,SAHO;IAIf8C,YAAY,EAAEhC,eAAe,GAAGgC,YAAH,GAAkB;EAJhC,CAAjB;EAMA,IAAIM,YAAY,GAAG,IAAIzD,iBAAJ,CAAsBc,YAAtB,EAAoCC,aAApC,EAAmDuC,UAAnD,CAAnB;;EAEA,IAAI,CAACrD,SAAS,CAACyD,YAAV,CAAuB5C,YAAvB,CAAD,IAAyC,CAACb,SAAS,CAACyD,YAAV,CAAuB3C,aAAvB,CAA9C,EAAqF;IACnF0C,YAAY,CAACE,OAAb,CAAqBC,eAArB,GAAuC,KAAvC;EACD;;EAED,IAAIxB,QAAQ,GAAG,IAAIlC,cAAJ,CAAmB;IAChC2D,WAAW,EAAE1C,eADmB;IAEhCU,OAAO,EAAEE,MAAM,CAAC+B,MAAP,CAAc;MACrB3C,eAAe,EAAEA;IADI,CAAd,EAENb,mBAAmB,CAACY,eAApB,CAAoCW,OAF9B,CAFuB;IAKhCJ,QAAQ,EAAEtB,aAAa,CAAC4D,KAAd,CAAoB9C,MAAM,CAACQ,QAA3B,CALsB;IAMhCuC,cAAc,EAAE/C,MAAM,CAAC+C,cANS;IAOhCC,YAAY,EAAEhD,MAAM,CAACgD;EAPW,CAAnB,CAAf;EASA7B,QAAQ,CAACX,QAAT,CAAkB,UAAlB,EAA8BC,KAA9B,GAAsC+B,YAAY,CAACE,OAAnD;EACAvB,QAAQ,CAACX,QAAT,CAAkB,OAAlB,EAA2BC,KAA3B,GAAmCd,KAAnC;EACAwB,QAAQ,CAACX,QAAT,CAAkB,eAAlB,EAAmCC,KAAnC,GAA2CuB,aAA3C;;EAEA,IAAI9B,eAAJ,EAAqB;IACnBiB,QAAQ,CAACX,QAAT,CAAkB,QAAlB,EAA4BC,KAA5B,GAAoC+B,YAAY,CAACN,YAAjD;EACD;;EAED,KAAKf,QAAL,GAAgBA,QAAhB;;EAEA,KAAK8B,QAAL,GAAgB,UAAUC,QAAV,EAAoBC,KAApB,EAA2BC,MAA3B,EAAmC;IACjDjC,QAAQ,CAACX,QAAT,CAAkB,aAAlB,EAAiCC,KAAjC,GAAyCf,KAAK,CAACa,WAAN,IAAqB6C,MAAM,CAACC,QAAP,CAAgBC,MAAhB,KAA2BF,MAAM,CAACC,QAAP,CAAgBE,CAAhE,CAAzC,CADiD,CAC4D;IAC7G;IACA;;IAEApC,QAAQ,CAACX,QAAT,CAAkB,SAAlB,EAA6BC,KAA7B,GAAqCf,KAAK,CAACgB,OAA3C;IACAN,QAAQ,CAACoD,IAAT,CAAcJ,MAAM,CAACC,QAArB,EAA+BI,SAA/B;IACApD,QAAQ,CAACmD,IAAT,CAAcpD,QAAd,EAAwBsD,OAAxB,CAAgCvD,KAAhC;IACAgB,QAAQ,CAACX,QAAT,CAAkB,SAAlB,EAA6BC,KAA7B,GAAqC,CAACL,QAAQ,CAACuD,GAAT,CAAatD,QAAb,IAAyB,CAA1B,IAA+B,CAApE,CARiD,CAQsB;IACvE;;IAEAmB,sBAAsB,CAACoC,qBAAvB,CAA6ClE,KAAK,CAACmE,WAAnD;IACApC,mBAAmB,CAACmC,qBAApB,CAA0CR,MAAM,CAACS,WAAjD;IACAnC,cAAc,CAACoC,eAAf,CAA+BpE,KAAK,CAACmE,WAArC;IACAtC,MAAM,CAACN,GAAP,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB;IACAM,MAAM,CAACwC,YAAP,CAAoBrC,cAApB;IACAG,IAAI,CAACmC,UAAL,CAAgBxC,sBAAhB,EAAwCC,mBAAxC,EAhBiD,CAgBa;;IAE9D,IAAII,IAAI,CAAC8B,GAAL,CAASpC,MAAT,IAAmB,CAAvB,EAA0B;IAC1BM,IAAI,CAAC6B,OAAL,CAAanC,MAAb,EAAqB0C,MAArB;IACApC,IAAI,CAACqC,GAAL,CAAS1C,sBAAT;IACAE,cAAc,CAACoC,eAAf,CAA+BV,MAAM,CAACS,WAAtC;IACAlC,cAAc,CAACV,GAAf,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAC,CAA1B;IACAU,cAAc,CAACoC,YAAf,CAA4BrC,cAA5B;IACAC,cAAc,CAACuC,GAAf,CAAmBzC,mBAAnB;IACAK,MAAM,CAACkC,UAAP,CAAkBxC,sBAAlB,EAA0CG,cAA1C;IACAG,MAAM,CAAC4B,OAAP,CAAenC,MAAf,EAAuB0C,MAAvB;IACAnC,MAAM,CAACoC,GAAP,CAAW1C,sBAAX;IACAS,aAAa,CAACoB,QAAd,CAAuBG,IAAvB,CAA4B3B,IAA5B;IACAI,aAAa,CAACkC,EAAd,CAAiBlD,GAAjB,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B;IACAgB,aAAa,CAACkC,EAAd,CAAiBJ,YAAjB,CAA8BrC,cAA9B;IACAO,aAAa,CAACkC,EAAd,CAAiBT,OAAjB,CAAyBnC,MAAzB;IACAU,aAAa,CAACmC,MAAd,CAAqBtC,MAArB;IACAG,aAAa,CAACoC,GAAd,GAAoBjB,MAAM,CAACiB,GAA3B,CAjCiD,CAiCjB;;IAEhCpC,aAAa,CAACqC,iBAAd;IACArC,aAAa,CAACsC,gBAAd,CAA+Bf,IAA/B,CAAoCJ,MAAM,CAACmB,gBAA3C,EApCiD,CAoCa;;IAE9DvC,aAAa,CAACf,GAAd,CAAkB,GAAlB,EAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,GAAhD,EAAqD,GAArD,EAA0D,GAA1D,EAA+D,GAA/D,EAAoE,GAApE,EAAyE,GAAzE,EAA8E,GAA9E,EAAmF,GAAnF,EAAwF,GAAxF,EAA6F,GAA7F;IACAe,aAAa,CAACwC,QAAd,CAAuBvC,aAAa,CAACsC,gBAArC;IACAvC,aAAa,CAACwC,QAAd,CAAuBvC,aAAa,CAACwC,kBAArC;IACAzC,aAAa,CAACwC,QAAd,CAAuB9E,KAAK,CAACmE,WAA7B,EAzCiD,CAyCN;IAC3C;;IAEAvC,cAAc,CAACoD,6BAAf,CAA6CnD,MAA7C,EAAqDC,sBAArD;IACAF,cAAc,CAACyC,YAAf,CAA4B9B,aAAa,CAACwC,kBAA1C;IACA7C,SAAS,CAACX,GAAV,CAAcK,cAAc,CAACC,MAAf,CAAsBoD,CAApC,EAAuCrD,cAAc,CAACC,MAAf,CAAsBgC,CAA7D,EAAgEjC,cAAc,CAACC,MAAf,CAAsBqD,CAAtF,EAAyFtD,cAAc,CAACuD,QAAxG;IACA,IAAIN,gBAAgB,GAAGtC,aAAa,CAACsC,gBAArC;IACAxC,CAAC,CAAC4C,CAAF,GAAM,CAACG,IAAI,CAACC,IAAL,CAAUnD,SAAS,CAAC+C,CAApB,IAAyBJ,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,CAA1B,IAA0DT,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,CAAhE;IACAjD,CAAC,CAACwB,CAAF,GAAM,CAACuB,IAAI,CAACC,IAAL,CAAUnD,SAAS,CAAC2B,CAApB,IAAyBgB,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,CAA1B,IAA0DT,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,CAAhE;IACAjD,CAAC,CAAC6C,CAAF,GAAM,CAAC,GAAP;IACA7C,CAAC,CAACkD,CAAF,GAAM,CAAC,MAAMV,gBAAgB,CAACS,QAAjB,CAA0B,EAA1B,CAAP,IAAwCT,gBAAgB,CAACS,QAAjB,CAA0B,EAA1B,CAA9C,CAnDiD,CAmD4B;;IAE7EpD,SAAS,CAACsD,cAAV,CAAyB,MAAMtD,SAAS,CAAC+B,GAAV,CAAc5B,CAAd,CAA/B,EArDiD,CAqDC;;IAElDwC,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,IAA+BpD,SAAS,CAAC+C,CAAzC;IACAJ,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,IAA+BpD,SAAS,CAAC2B,CAAzC;IACAgB,gBAAgB,CAACS,QAAjB,CAA0B,EAA1B,IAAgCpD,SAAS,CAACgD,CAAV,GAAc,GAAd,GAAoB7E,QAApD;IACAwE,gBAAgB,CAACS,QAAjB,CAA0B,EAA1B,IAAgCpD,SAAS,CAACqD,CAA1C,CA1DiD,CA0DJ;;IAE7CzC,YAAY,CAACE,OAAb,CAAqByC,QAArB,GAAgCjC,QAAQ,CAACkC,cAAzC,CA5DiD,CA4DQ;;IAEzD,IAAIC,mBAAmB,GAAGnC,QAAQ,CAACoC,eAAT,EAA1B;IACA,IAAIC,gBAAgB,GAAGrC,QAAQ,CAACsC,EAAT,CAAYC,OAAnC;IACA,IAAIC,uBAAuB,GAAGxC,QAAQ,CAACyC,SAAT,CAAmBC,UAAjD;IACA1C,QAAQ,CAACsC,EAAT,CAAYC,OAAZ,GAAsB,KAAtB,CAjEiD,CAiEpB;;IAE7BvC,QAAQ,CAACyC,SAAT,CAAmBC,UAAnB,GAAgC,KAAhC,CAnEiD,CAmEV;;IAEvC1C,QAAQ,CAAC2C,eAAT,CAAyBrD,YAAzB;IACAU,QAAQ,CAAC4C,KAAT,CAAeC,OAAf,CAAuBC,KAAvB,CAA6BC,OAA7B,CAAqC,IAArC,EAtEiD,CAsEL;;IAE5C,IAAI/C,QAAQ,CAACgD,SAAT,KAAuB,KAA3B,EAAkChD,QAAQ,CAACiD,KAAT;IAClCjD,QAAQ,CAACkD,MAAT,CAAgBjD,KAAhB,EAAuBlB,aAAvB;IACAiB,QAAQ,CAACsC,EAAT,CAAYC,OAAZ,GAAsBF,gBAAtB;IACArC,QAAQ,CAACyC,SAAT,CAAmBC,UAAnB,GAAgCF,uBAAhC;IACAxC,QAAQ,CAAC2C,eAAT,CAAyBR,mBAAzB,EA5EiD,CA4EF;;IAE/C,IAAIgB,QAAQ,GAAGjD,MAAM,CAACiD,QAAtB;;IAEA,IAAIA,QAAQ,KAAKzG,SAAjB,EAA4B;MAC1BsD,QAAQ,CAAC4C,KAAT,CAAeO,QAAf,CAAwBA,QAAxB;IACD,CAlFgD,CAkF/C;;EAEH,CApFD;;EAsFA,KAAKf,eAAL,GAAuB,YAAY;IACjC,OAAO9C,YAAP;EACD,CAFD;AAGD,CA1LD;;AA4LAnD,mBAAmB,CAACiH,SAApB,GAAgCxF,MAAM,CAACyF,MAAP,CAAclI,IAAI,CAACiI,SAAnB,CAAhC;AACAjH,mBAAmB,CAACiH,SAApB,CAA8BE,WAA9B,GAA4CnH,mBAA5C;AACAA,mBAAmB,CAACY,eAApB,GAAsC;EACpC;EACAW,OAAO,EAAE;IACPC,qBAAqB,EAAE,IADhB;IAEPQ,SAAS,EAAE;EAFJ,CAF2B;EAMpCb,QAAQ,EAAE;IACRb,KAAK,EAAE;MACLc,KAAK,EAAE;IADF,CADC;IAIRgG,QAAQ,EAAE;MACRhG,KAAK,EAAE;IADC,CAJF;IAORiG,MAAM,EAAE;MACNjG,KAAK,EAAE;IADD,CAPA;IAURuB,aAAa,EAAE;MACbvB,KAAK,EAAE;IADM,CAVP;IAaRF,WAAW,EAAE;MACXE,KAAK,EAAE;IADI,CAbL;IAgBRC,OAAO,EAAE;MACPD,KAAK,EAAE;IADA,CAhBD;IAmBRkG,OAAO,EAAE;MACPlG,KAAK,EAAE;IADA;EAnBD,CAN0B;EA6BpCuC,YAAY,EAAE,CAAC,6BAAD,EAAgC,mBAAhC,EAAqD,eAArD,EAAsE,+CAAtE,EAAuH,4EAAvH,EAAqM,GAArM,EAA0M4D,IAA1M,CAA+M,IAA/M,CA7BsB;EA8BpC7D,cAAc;AA9BsB,CAAtC;AAkEA,SAAS1D,mBAAT"},"metadata":{},"sourceType":"module"}