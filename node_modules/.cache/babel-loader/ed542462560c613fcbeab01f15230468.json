{"ast":null,"code":"import { DataTextureLoader, UnsignedByteType, HalfFloatType, FloatType, DataUtils, RGBFormat, RGBEFormat, LinearEncoding, LinearFilter, RGBEEncoding, NearestFilter } from 'three'; // http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function RGBELoader(manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = UnsignedByteType;\n};\n\nRGBELoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: RGBELoader,\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse: function parse(buffer) {\n    var\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n        rgbe_write_error = 2,\n        rgbe_format_error = 3,\n        rgbe_memory_error = 4,\n        rgbe_error = function rgbe_error(rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n        RGBE_VALID_FORMAT = 2,\n        RGBE_VALID_DIMENSIONS = 4,\n        NEWLINE = '\\n',\n        fgets = function fgets(buffer, lineLimit, consume) {\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      var p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunkSize = 128,\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        byteCode = m.charCodeAt(i);\n        if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {\n      var line,\n          match,\n          // regexes to parse header info fields\n      magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n      header = {\n        valid: 0\n        /* indicate which fields are valid */\n        ,\n        string: ''\n        /* the actual header string */\n        ,\n        comments: ''\n        /* comments found in header */\n        ,\n        programtype: 'RGBE'\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        ,\n        format: ''\n        /* RGBE format, default 32-bit_rle_rgbe */\n        ,\n        gamma: 1.0\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        ,\n        exposure: 1.0\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        ,\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, 'no header found');\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, 'bad initial token');\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + '\\n';\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + '\\n';\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + '\\n';\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, 'missing format specifier');\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n      }\n\n      return header;\n    },\n        RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {\n      var data_rgba,\n          offset,\n          pos,\n          count,\n          byteValue,\n          scanline_buffer,\n          ptr,\n          ptr_end,\n          i,\n          l,\n          off,\n          isEncodedRun,\n          scanline_width = w,\n          num_scanlines = h,\n          rgbeStart;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n      }\n\n      data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n      }\n\n      offset = 0;\n      pos = 0;\n      ptr_end = 4 * scanline_width;\n      rgbeStart = new Uint8Array(4);\n      scanline_buffer = new Uint8Array(ptr_end); // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        ptr = 0;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, 'bad scanline data');\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            byteValue = buffer[pos++];\n\n            for (i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        l = scanline_width; //scanline_buffer.byteLength;\n\n        for (i = 0; i < l; i++) {\n          off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    var RGBEByteToRGBHalf = function RGBEByteToRGBHalf(sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);\n    };\n\n    var byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    var rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      var w = rgbe_header_info.width,\n          h = rgbe_header_info.height,\n          image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        switch (this.type) {\n          case UnsignedByteType:\n            var data = image_rgba_data;\n            var format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n            var type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var floatArray = new Float32Array(numElements);\n\n            for (var j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            var data = floatArray;\n            var format = RGBFormat;\n            var type = FloatType;\n            break;\n\n          case HalfFloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var halfArray = new Uint16Array(numElements);\n\n            for (var _j = 0; _j < numElements; _j++) {\n              RGBEByteToRGBHalf(image_rgba_data, _j * 4, halfArray, _j * 3);\n            }\n\n            var data = halfArray;\n            var format = RGBFormat;\n            var type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  },\n  setDataType: function setDataType(value) {\n    this.type = value;\n    return this;\n  },\n  load: function load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\nexport { RGBELoader };","map":{"version":3,"names":["DataTextureLoader","UnsignedByteType","HalfFloatType","FloatType","DataUtils","RGBFormat","RGBEFormat","LinearEncoding","LinearFilter","RGBEEncoding","NearestFilter","RGBELoader","manager","call","type","prototype","Object","assign","create","constructor","parse","buffer","RGBE_RETURN_FAILURE","rgbe_read_error","rgbe_write_error","rgbe_format_error","rgbe_memory_error","rgbe_error","rgbe_error_code","msg","console","error","RGBE_VALID_PROGRAMTYPE","RGBE_VALID_FORMAT","RGBE_VALID_DIMENSIONS","NEWLINE","fgets","lineLimit","consume","p","pos","i","len","s","chunkSize","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBE_ReadHeader","line","match","magic_token_re","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","RGBE_ReadPixels_RLE","w","h","data_rgba","offset","count","byteValue","scanline_buffer","ptr","ptr_end","l","off","isEncodedRun","scanline_width","num_scanlines","rgbeStart","Uint8Array","set","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","Math","pow","RGBEByteToRGBHalf","toHalfFloat","byteArray","rgbe_header_info","image_rgba_data","data","numElements","floatArray","Float32Array","j","halfArray","setDataType","value","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY"],"sources":["/Users/98yaroslavgorban/Desktop/gltfjsx-forked/node_modules/three-stdlib/loaders/RGBELoader.js"],"sourcesContent":["import { DataTextureLoader, UnsignedByteType, HalfFloatType, FloatType, DataUtils, RGBFormat, RGBEFormat, LinearEncoding, LinearFilter, RGBEEncoding, NearestFilter } from 'three';\n\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function (manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = UnsignedByteType;\n};\n\nRGBELoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: RGBELoader,\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse: function (buffer) {\n    var\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n        rgbe_write_error = 2,\n        rgbe_format_error = 3,\n        rgbe_memory_error = 4,\n        rgbe_error = function (rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n        RGBE_VALID_FORMAT = 2,\n        RGBE_VALID_DIMENSIONS = 4,\n        NEWLINE = '\\n',\n        fgets = function (buffer, lineLimit, consume) {\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      var p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunkSize = 128,\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        byteCode = m.charCodeAt(i);\n        if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function (buffer) {\n      var line,\n          match,\n          // regexes to parse header info fields\n      magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n      header = {\n        valid: 0\n        /* indicate which fields are valid */\n        ,\n        string: ''\n        /* the actual header string */\n        ,\n        comments: ''\n        /* comments found in header */\n        ,\n        programtype: 'RGBE'\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        ,\n        format: ''\n        /* RGBE format, default 32-bit_rle_rgbe */\n        ,\n        gamma: 1.0\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        ,\n        exposure: 1.0\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        ,\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, 'no header found');\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, 'bad initial token');\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + '\\n';\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + '\\n';\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + '\\n';\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, 'missing format specifier');\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n      }\n\n      return header;\n    },\n        RGBE_ReadPixels_RLE = function (buffer, w, h) {\n      var data_rgba,\n          offset,\n          pos,\n          count,\n          byteValue,\n          scanline_buffer,\n          ptr,\n          ptr_end,\n          i,\n          l,\n          off,\n          isEncodedRun,\n          scanline_width = w,\n          num_scanlines = h,\n          rgbeStart;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n      }\n\n      data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n      }\n\n      offset = 0;\n      pos = 0;\n      ptr_end = 4 * scanline_width;\n      rgbeStart = new Uint8Array(4);\n      scanline_buffer = new Uint8Array(ptr_end); // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        ptr = 0;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, 'bad scanline data');\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            byteValue = buffer[pos++];\n\n            for (i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        l = scanline_width; //scanline_buffer.byteLength;\n\n        for (i = 0; i < l; i++) {\n          off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    var RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    var RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);\n    };\n\n    var byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    var rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      var w = rgbe_header_info.width,\n          h = rgbe_header_info.height,\n          image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        switch (this.type) {\n          case UnsignedByteType:\n            var data = image_rgba_data;\n            var format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n            var type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var floatArray = new Float32Array(numElements);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            var data = floatArray;\n            var format = RGBFormat;\n            var type = FloatType;\n            break;\n\n          case HalfFloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var halfArray = new Uint16Array(numElements);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\n            }\n\n            var data = halfArray;\n            var format = RGBFormat;\n            var type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  },\n  setDataType: function (value) {\n    this.type = value;\n    return this;\n  },\n  load: function (url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\n\nexport { RGBELoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}