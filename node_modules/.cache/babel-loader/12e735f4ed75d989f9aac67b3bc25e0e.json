{"ast":null,"code":"import { forEach, has, isArray, isFunction, peek, some } from \"../../../utils/utils\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"../../grammar/gast/gast_public\";\nimport { Lexer } from \"../../../scan/lexer_public\";\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\";\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\";\nimport { END_OF_FILE } from \"../parser\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\";\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = createToken({\n  name: \"RECORDING_PHASE_TOKEN\",\n  pattern: Lexer.NA\n});\naugmentTokenTypes([RFT]);\nvar RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" + \"\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\n\nvar GastRecorder =\n/** @class */\nfunction () {\n  function GastRecorder() {}\n\n  GastRecorder.prototype.initGastRecorder = function (config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  };\n\n  GastRecorder.prototype.enableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", function () {\n      var _loop_1 = function _loop_1(i) {\n        var idx = i > 0 ? i : \"\";\n\n        _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"OPTION\" + idx] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n\n        _this[\"OR\" + idx] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n\n        _this[\"MANY\" + idx] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n\n        _this[\"MANY_SEP\" + idx] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      };\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n\n\n      for (var i = 0; i < 10; i++) {\n        _loop_1(i);\n      } // DSL methods with the idx(suffix) as an argument\n\n\n      _this[\"consume\"] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"subrule\"] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"option\"] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n\n      _this[\"or\"] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n\n      _this[\"many\"] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n\n      _this[\"atLeastOne\"] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n\n      _this.ACTION = _this.ACTION_RECORD;\n      _this.BACKTRACK = _this.BACKTRACK_RECORD;\n      _this.LA = _this.LA_RECORD;\n    });\n  };\n\n  GastRecorder.prototype.disableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = false; // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n\n    this.TRACE_INIT(\"Deleting Recording methods\", function () {\n      for (var i = 0; i < 10; i++) {\n        var idx = i > 0 ? i : \"\";\n        delete _this[\"CONSUME\" + idx];\n        delete _this[\"SUBRULE\" + idx];\n        delete _this[\"OPTION\" + idx];\n        delete _this[\"OR\" + idx];\n        delete _this[\"MANY\" + idx];\n        delete _this[\"MANY_SEP\" + idx];\n        delete _this[\"AT_LEAST_ONE\" + idx];\n        delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n      }\n\n      delete _this[\"consume\"];\n      delete _this[\"subrule\"];\n      delete _this[\"option\"];\n      delete _this[\"or\"];\n      delete _this[\"many\"];\n      delete _this[\"atLeastOne\"];\n      delete _this.ACTION;\n      delete _this.BACKTRACK;\n      delete _this.LA;\n    });\n  }; // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n\n\n  GastRecorder.prototype.ACTION_RECORD = function (impl) {\n    // NO-OP during recording\n    return;\n  }; // Executing backtracking logic will break our recording logic assumptions\n\n\n  GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n    return function () {\n      return true;\n    };\n  }; // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n\n\n  GastRecorder.prototype.LA_RECORD = function (howMuch) {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE;\n  };\n\n  GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n    try {\n      var newTopLevelRule = new Rule({\n        definition: [],\n        name: name\n      });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' + \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n\n      throw originalError;\n    }\n  }; // Implementation of parsing DSL\n\n\n  GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  };\n\n  GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = peek(this.recordingProdStack);\n    var ruleName = ruleToCall[\"ruleName\"];\n    var newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  };\n\n  GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!hasShortKeyProperty(tokType)) {\n      var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = peek(this.recordingProdStack);\n    var newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  };\n\n  return GastRecorder;\n}();\n\nexport { GastRecorder };\n\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n  if (handleSep === void 0) {\n    handleSep = false;\n  }\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = peek(this.recordingProdStack);\n  var grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  var newProd = new prodConstructor({\n    definition: [],\n    idx: occurrence\n  });\n\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction recordOrProd(mainProdArg, occurrence) {\n  var _this = this;\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = peek(this.recordingProdStack); // Only an array of alternatives\n\n  var hasOptions = isArray(mainProdArg) === false;\n  var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  var newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  var hasPredicates = some(alts, function (currAlt) {\n    return isFunction(currAlt.GATE);\n  });\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  forEach(alts, function (currAlt) {\n    var currAltFlat = new Alternative({\n      definition: []\n    });\n    newOrProd.definition.push(currAltFlat);\n\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    } // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n\n    _this.recordingProdStack.push(currAltFlat);\n\n    currAlt.ALT.call(_this);\n\n    _this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : \"\" + idx;\n}\n\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    var error = new Error( // The stack trace will contain all the needed details\n    \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" + (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}","map":{"version":3,"mappings":"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","names":["forEach","has","isArray","isFunction","peek","some","Alternation","Alternative","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Rule","Terminal","Lexer","augmentTokenTypes","hasShortKeyProperty","createToken","createTokenInstance","END_OF_FILE","BITS_FOR_OCCURRENCE_IDX","RECORDING_NULL_OBJECT","description","Object","freeze","HANDLE_SEPARATOR","MAX_METHOD_IDX","Math","pow","RFT","name","pattern","NA","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","children","GastRecorder","config","recordingProdStack","RECORDING_PHASE","TRACE_INIT","i","idx","_this","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION","ACTION_RECORD","BACKTRACK","BACKTRACK_RECORD","LA","LA_RECORD","impl","grammarRule","args","howMuch","def","newTopLevelRule","definition","push","call","pop","originalError","KNOWN_RECORDER_ERROR","message","mutabilityError","actionORMethodDef","occurrence","recordProd","options","altsOrOpts","recordOrProd","ruleToCall","assertMethodIdxIsValid","error","Error","getIdxSuffix","JSON","stringify","prevProd","ruleName","newNoneTerminal","nonTerminalName","referencedRule","undefined","outputCst","tokType","terminalType","prodConstructor","mainProdArg","handleSep","grammarAction","DEF","newProd","separator","SEP","maxLookahead","MAX_LOOKAHEAD","hasOptions","alts","newOrProd","ignoreAmbiguities","IGNORE_AMBIGUITIES","hasPredicates","currAlt","GATE","currAltFlat","ALT"],"sourceRoot":"","sources":["../../../../../src/parse/parser/traits/gast_recorder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}