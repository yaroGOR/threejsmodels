{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n/**\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nvar PRWMLoader = function () {\n  var bigEndianPlatform = null;\n  /**\n   * Check if the endianness of the platform is big-endian (most significant bit first)\n   * @returns {boolean} True if big-endian, false if little-endian\n   */\n\n  function isBigEndianPlatform() {\n    if (bigEndianPlatform === null) {\n      var buffer = new ArrayBuffer(2),\n          uint8Array = new Uint8Array(buffer),\n          uint16Array = new Uint16Array(buffer);\n      uint8Array[0] = 0xaa; // set first byte\n\n      uint8Array[1] = 0xbb; // set second byte\n\n      bigEndianPlatform = uint16Array[0] === 0xaabb;\n    }\n\n    return bigEndianPlatform;\n  } // match the values defined in the spec to the TypedArray types\n\n\n  var InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array]; // define the method to use on a DataView, corresponding the TypedArray type\n\n  var getMethods = {\n    Uint16Array: 'getUint16',\n    Uint32Array: 'getUint32',\n    Int16Array: 'getInt16',\n    Int32Array: 'getInt32',\n    Float32Array: 'getFloat32',\n    Float64Array: 'getFloat64'\n  };\n\n  function copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n    var bytesPerElement = viewType.BYTES_PER_ELEMENT,\n        result;\n\n    if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n      result = new viewType(sourceArrayBuffer, position, length);\n    } else {\n      var readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n          getMethod = getMethods[viewType.name],\n          littleEndian = !fromBigEndian,\n          i = 0;\n      result = new viewType(length);\n\n      for (; i < length; i++) {\n        result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n      }\n    }\n\n    return result;\n  }\n\n  function decodePrwm(buffer) {\n    var array = new Uint8Array(buffer),\n        version = array[0],\n        flags = array[1],\n        indexedGeometry = !!(flags >> 7 & 0x01),\n        indicesType = flags >> 6 & 0x01,\n        bigEndian = (flags >> 5 & 0x01) === 1,\n        attributesNumber = flags & 0x1f,\n        valuesNumber = 0,\n        indicesNumber = 0;\n\n    if (bigEndian) {\n      valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n      indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n    } else {\n      valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n      indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n    }\n    /** PRELIMINARY CHECKS **/\n\n\n    if (version === 0) {\n      throw new Error('PRWM decoder: Invalid format version: 0');\n    } else if (version !== 1) {\n      throw new Error('PRWM decoder: Unsupported format version: ' + version);\n    }\n\n    if (!indexedGeometry) {\n      if (indicesType !== 0) {\n        throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\n      } else if (indicesNumber !== 0) {\n        throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\n      }\n    }\n    /** PARSING **/\n\n\n    var pos = 8;\n    var attributes = {},\n        attributeName,\n        char,\n        attributeType,\n        cardinality,\n        encodingType,\n        arrayType,\n        values,\n        indices,\n        i;\n\n    for (i = 0; i < attributesNumber; i++) {\n      attributeName = '';\n\n      while (pos < array.length) {\n        char = array[pos];\n        pos++;\n\n        if (char === 0) {\n          break;\n        } else {\n          attributeName += String.fromCharCode(char);\n        }\n      }\n\n      flags = array[pos];\n      attributeType = flags >> 7 & 0x01;\n      cardinality = (flags >> 4 & 0x03) + 1;\n      encodingType = flags & 0x0f;\n      arrayType = InvertedEncodingTypes[encodingType];\n      pos++; // padding to next multiple of 4\n\n      pos = Math.ceil(pos / 4) * 4;\n      values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n      pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n      attributes[attributeName] = {\n        type: attributeType,\n        cardinality: cardinality,\n        values: values\n      };\n    }\n\n    pos = Math.ceil(pos / 4) * 4;\n    indices = null;\n\n    if (indexedGeometry) {\n      indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n    }\n\n    return {\n      version: version,\n      attributes: attributes,\n      indices: indices\n    };\n  } // Define the public interface\n\n\n  function PRWMLoader(manager) {\n    Loader.call(this, manager);\n  }\n\n  PRWMLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: PRWMLoader,\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      url = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le');\n      loader.load(url, function (arrayBuffer) {\n        try {\n          onLoad(scope.parse(arrayBuffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function parse(arrayBuffer) {\n      var data = decodePrwm(arrayBuffer),\n          attributesKey = Object.keys(data.attributes),\n          bufferGeometry = new BufferGeometry(),\n          attribute,\n          i;\n\n      for (i = 0; i < attributesKey.length; i++) {\n        attribute = data.attributes[attributesKey[i]];\n        bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n      }\n\n      if (data.indices !== null) {\n        bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n      }\n\n      return bufferGeometry;\n    }\n  });\n\n  PRWMLoader.isBigEndianPlatform = function () {\n    return isBigEndianPlatform();\n  };\n\n  return PRWMLoader;\n}();\n\nexport { PRWMLoader };","map":{"version":3,"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","PRWMLoader","bigEndianPlatform","isBigEndianPlatform","buffer","ArrayBuffer","uint8Array","Uint8Array","uint16Array","Uint16Array","InvertedEncodingTypes","Float32Array","Int8Array","Int16Array","Int32Array","Uint32Array","getMethods","Float64Array","copyFromBuffer","sourceArrayBuffer","viewType","position","length","fromBigEndian","bytesPerElement","BYTES_PER_ELEMENT","result","readView","DataView","getMethod","name","littleEndian","i","decodePrwm","array","version","flags","indexedGeometry","indicesType","bigEndian","attributesNumber","valuesNumber","indicesNumber","Error","pos","attributes","attributeName","char","attributeType","cardinality","encodingType","arrayType","values","indices","String","fromCharCode","Math","ceil","type","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","replace","arrayBuffer","parse","e","console","error","itemError","data","attributesKey","keys","bufferGeometry","attribute","setAttribute","normalized","setIndex"],"sources":["/Users/98yaroslavgorban/Desktop/gltfjsx-forked/node_modules/three-stdlib/loaders/PRWMLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n\n/**\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nvar PRWMLoader = function () {\n  var bigEndianPlatform = null;\n  /**\n   * Check if the endianness of the platform is big-endian (most significant bit first)\n   * @returns {boolean} True if big-endian, false if little-endian\n   */\n\n  function isBigEndianPlatform() {\n    if (bigEndianPlatform === null) {\n      var buffer = new ArrayBuffer(2),\n          uint8Array = new Uint8Array(buffer),\n          uint16Array = new Uint16Array(buffer);\n      uint8Array[0] = 0xaa; // set first byte\n\n      uint8Array[1] = 0xbb; // set second byte\n\n      bigEndianPlatform = uint16Array[0] === 0xaabb;\n    }\n\n    return bigEndianPlatform;\n  } // match the values defined in the spec to the TypedArray types\n\n\n  var InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array]; // define the method to use on a DataView, corresponding the TypedArray type\n\n  var getMethods = {\n    Uint16Array: 'getUint16',\n    Uint32Array: 'getUint32',\n    Int16Array: 'getInt16',\n    Int32Array: 'getInt32',\n    Float32Array: 'getFloat32',\n    Float64Array: 'getFloat64'\n  };\n\n  function copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n    var bytesPerElement = viewType.BYTES_PER_ELEMENT,\n        result;\n\n    if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n      result = new viewType(sourceArrayBuffer, position, length);\n    } else {\n      var readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n          getMethod = getMethods[viewType.name],\n          littleEndian = !fromBigEndian,\n          i = 0;\n      result = new viewType(length);\n\n      for (; i < length; i++) {\n        result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n      }\n    }\n\n    return result;\n  }\n\n  function decodePrwm(buffer) {\n    var array = new Uint8Array(buffer),\n        version = array[0],\n        flags = array[1],\n        indexedGeometry = !!(flags >> 7 & 0x01),\n        indicesType = flags >> 6 & 0x01,\n        bigEndian = (flags >> 5 & 0x01) === 1,\n        attributesNumber = flags & 0x1f,\n        valuesNumber = 0,\n        indicesNumber = 0;\n\n    if (bigEndian) {\n      valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n      indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n    } else {\n      valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n      indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n    }\n    /** PRELIMINARY CHECKS **/\n\n\n    if (version === 0) {\n      throw new Error('PRWM decoder: Invalid format version: 0');\n    } else if (version !== 1) {\n      throw new Error('PRWM decoder: Unsupported format version: ' + version);\n    }\n\n    if (!indexedGeometry) {\n      if (indicesType !== 0) {\n        throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\n      } else if (indicesNumber !== 0) {\n        throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\n      }\n    }\n    /** PARSING **/\n\n\n    var pos = 8;\n    var attributes = {},\n        attributeName,\n        char,\n        attributeType,\n        cardinality,\n        encodingType,\n        arrayType,\n        values,\n        indices,\n        i;\n\n    for (i = 0; i < attributesNumber; i++) {\n      attributeName = '';\n\n      while (pos < array.length) {\n        char = array[pos];\n        pos++;\n\n        if (char === 0) {\n          break;\n        } else {\n          attributeName += String.fromCharCode(char);\n        }\n      }\n\n      flags = array[pos];\n      attributeType = flags >> 7 & 0x01;\n      cardinality = (flags >> 4 & 0x03) + 1;\n      encodingType = flags & 0x0f;\n      arrayType = InvertedEncodingTypes[encodingType];\n      pos++; // padding to next multiple of 4\n\n      pos = Math.ceil(pos / 4) * 4;\n      values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n      pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n      attributes[attributeName] = {\n        type: attributeType,\n        cardinality: cardinality,\n        values: values\n      };\n    }\n\n    pos = Math.ceil(pos / 4) * 4;\n    indices = null;\n\n    if (indexedGeometry) {\n      indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n    }\n\n    return {\n      version: version,\n      attributes: attributes,\n      indices: indices\n    };\n  } // Define the public interface\n\n\n  function PRWMLoader(manager) {\n    Loader.call(this, manager);\n  }\n\n  PRWMLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: PRWMLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      url = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le');\n      loader.load(url, function (arrayBuffer) {\n        try {\n          onLoad(scope.parse(arrayBuffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function (arrayBuffer) {\n      var data = decodePrwm(arrayBuffer),\n          attributesKey = Object.keys(data.attributes),\n          bufferGeometry = new BufferGeometry(),\n          attribute,\n          i;\n\n      for (i = 0; i < attributesKey.length; i++) {\n        attribute = data.attributes[attributesKey[i]];\n        bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n      }\n\n      if (data.indices !== null) {\n        bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n      }\n\n      return bufferGeometry;\n    }\n  });\n\n  PRWMLoader.isBigEndianPlatform = function () {\n    return isBigEndianPlatform();\n  };\n\n  return PRWMLoader;\n}();\n\nexport { PRWMLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}