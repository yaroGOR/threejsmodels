{"ast":null,"code":"import { createTokenInstance, EOF } from \"../../../scan/tokens_public\";\nimport { cloneArr, contains, dropRight, find, flatten, has, isEmpty, map } from \"../../../utils/utils\";\nimport { MismatchedTokenException } from \"../../exceptions_public\";\nimport { IN } from \"../../constants\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\nexport var EOF_FOLLOW_KEY = {};\nexport var IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport function InRuleRecoveryException(message) {\n  this.name = IN_RULE_RECOVERY_EXCEPTION;\n  this.message = message;\n}\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\n\nvar Recoverable =\n/** @class */\nfunction () {\n  function Recoverable() {}\n\n  Recoverable.prototype.initRecoverable = function (config) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n    this.recoveryEnabled = has(config, \"recoveryEnabled\") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled; // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  };\n\n  Recoverable.prototype.getTokenToInsert = function (tokType) {\n    var tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  };\n\n  Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n    return true;\n  };\n\n  Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n    var _this = this; // TODO: can the resyncTokenType be cached?\n\n\n    var reSyncTokType = this.findReSyncTokenType();\n    var savedLexerState = this.exportLexerState();\n    var resyncedTokens = [];\n    var passedResyncPoint = false;\n    var nextTokenWithoutResync = this.LA(1);\n    var currToken = this.LA(1);\n\n    var generateErrorMessage = function generateErrorMessage() {\n      var previousToken = _this.LA(0); // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n\n\n      var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: _this.getCurrRuleFullName()\n      });\n\n      var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0)); // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n\n      error.resyncedTokens = dropRight(resyncedTokens);\n\n      _this.SAVE_ERROR(error);\n    };\n\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return; // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage(); // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n\n        grammarRule.apply(this, grammarRuleArgs);\n        return; // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    } // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n\n\n    this.importLexerState(savedLexerState);\n  };\n\n  Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false;\n    } // arguments to try and perform resync into the next iteration of the many are missing\n\n\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n      return false;\n    } // no need to recover, next token is what we expect...\n\n\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    } // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n\n\n    if (this.isBackTracking()) {\n      return false;\n    } // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n\n\n    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n      return false;\n    }\n\n    return true;\n  }; // Error Recovery functionality\n\n\n  Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n    var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    var follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  };\n\n  Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      var tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      var nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  };\n\n  Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n  };\n\n  Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n    var _this = this;\n\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    } // must know the possible following tokens to perform single token insertion\n\n\n    if (isEmpty(follows)) {\n      return false;\n    }\n\n    var mismatchedTok = this.LA(1);\n    var isMisMatchedTokInFollows = find(follows, function (possibleFollowsTokType) {\n      return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n    }) !== undefined;\n    return isMisMatchedTokInFollows;\n  };\n\n  Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n    var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n    return isNextTokenWhatIsExpected;\n  };\n\n  Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n    var followKey = this.getCurrFollowKey();\n    var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return contains(currentRuleReSyncSet, tokenTypeIdx);\n  };\n\n  Recoverable.prototype.findReSyncTokenType = function () {\n    var allPossibleReSyncTokTypes = this.flattenFollowSet(); // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n\n    var nextToken = this.LA(1);\n    var k = 2;\n\n    while (true) {\n      var nextTokenType = nextToken.tokenType;\n\n      if (contains(allPossibleReSyncTokTypes, nextTokenType)) {\n        return nextTokenType;\n      }\n\n      nextToken = this.LA(k);\n      k++;\n    }\n  };\n\n  Recoverable.prototype.getCurrFollowKey = function () {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY;\n    }\n\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    };\n  };\n\n  Recoverable.prototype.buildFullFollowKeyStack = function () {\n    var _this = this;\n\n    var explicitRuleStack = this.RULE_STACK;\n    var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return map(explicitRuleStack, function (ruleName, idx) {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY;\n      }\n\n      return {\n        ruleName: _this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      };\n    });\n  };\n\n  Recoverable.prototype.flattenFollowSet = function () {\n    var _this = this;\n\n    var followStack = map(this.buildFullFollowKeyStack(), function (currKey) {\n      return _this.getFollowSetFromFollowKey(currKey);\n    });\n    return flatten(followStack);\n  };\n\n  Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF];\n    }\n\n    var followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n    return this.resyncFollows[followName];\n  }; // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n\n\n  Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token);\n    }\n\n    return resyncTokens;\n  };\n\n  Recoverable.prototype.reSyncTo = function (tokType) {\n    var resyncedTokens = [];\n    var nextTok = this.LA(1);\n\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    } // the last token is not part of the error.\n\n\n    return dropRight(resyncedTokens);\n  };\n\n  Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {// by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  };\n\n  Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n    var pathRuleStack = this.getHumanReadableRuleStack();\n    var pathOccurrenceStack = cloneArr(this.RULE_OCCURRENCE_STACK);\n    var grammarPath = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    };\n    return grammarPath;\n  };\n\n  Recoverable.prototype.getHumanReadableRuleStack = function () {\n    var _this = this;\n\n    return map(this.RULE_STACK, function (currShortName) {\n      return _this.shortRuleNameToFullName(currShortName);\n    });\n  };\n\n  return Recoverable;\n}();\n\nexport { Recoverable };\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  var firstAfterRepInfo = this.firstAfterRepMap[key];\n\n  if (firstAfterRepInfo === undefined) {\n    var currRuleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[currRuleName];\n    var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n\n  var expectTokAfterLastMatch = firstAfterRepInfo.token;\n  var nextTokIdx = firstAfterRepInfo.occurrence;\n  var isEndOfRule = firstAfterRepInfo.isEndOfRule; // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n\n  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {\n    expectTokAfterLastMatch = EOF;\n    nextTokIdx = 1;\n  }\n\n  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n  }\n}","map":{"version":3,"mappings":"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","names":["createTokenInstance","EOF","cloneArr","contains","dropRight","find","flatten","has","isEmpty","map","MismatchedTokenException","IN","DEFAULT_PARSER_CONFIG","EOF_FOLLOW_KEY","IN_RULE_RECOVERY_EXCEPTION","InRuleRecoveryException","message","name","prototype","Error","Recoverable","config","firstAfterRepMap","resyncFollows","recoveryEnabled","attemptInRepetitionRecovery","tokType","tokToInsert","NaN","isInsertedInRecovery","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","reSyncTokType","findReSyncTokenType","savedLexerState","exportLexerState","resyncedTokens","passedResyncPoint","nextTokenWithoutResync","LA","currToken","generateErrorMessage","previousToken","_this","msg","errorMessageProvider","buildMismatchTokenMessage","expected","actual","previous","ruleName","getCurrRuleFullName","error","SAVE_ERROR","tokenMatcher","call","apply","SKIP_TOKEN","addToResyncTokens","importLexerState","expectTokAfterLastMatch","nextTokIdx","notStuck","undefined","isBackTracking","canPerformInRuleRecovery","getFollowsForInRuleRecovery","tokIdxInRule","grammarPath","getCurrentGrammarPath","follows","getNextPossibleTokenTypes","canRecoverWithSingleTokenInsertion","getTokenToInsert","canRecoverWithSingleTokenDeletion","nextTok","consumeToken","expectedToken","canTokenTypeBeInsertedInRecovery","mismatchedTok","isMisMatchedTokInFollows","possibleFollowsTokType","isNextTokenWhatIsExpected","tokenTypeIdx","followKey","getCurrFollowKey","currentRuleReSyncSet","getFollowSetFromFollowKey","allPossibleReSyncTokTypes","flattenFollowSet","nextToken","k","nextTokenType","tokenType","RULE_STACK","length","currRuleShortName","getLastExplicitRuleShortName","currRuleIdx","getLastExplicitRuleOccurrenceIndex","prevRuleShortName","getPreviousExplicitRuleShortName","shortRuleNameToFullName","idxInCallingRule","inRule","explicitRuleStack","explicitOccurrenceStack","RULE_OCCURRENCE_STACK","idx","followStack","buildFullFollowKeyStack","currKey","followName","token","resyncTokens","push","prodFunc","args","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","pathRuleStack","getHumanReadableRuleStack","pathOccurrenceStack","ruleStack","occurrenceStack","lastTok","lastTokOccurrence","currShortName","key","getKeyForAutomaticLookahead","firstAfterRepInfo","currRuleName","ruleGrammar","getGAstProductions","walker","startWalking","occurrence","isEndOfRule","shouldInRepetitionRecoveryBeTried","tryInRepetitionRecovery"],"sourceRoot":"","sources":["../../../../../src/parse/parser/traits/recoverable.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}