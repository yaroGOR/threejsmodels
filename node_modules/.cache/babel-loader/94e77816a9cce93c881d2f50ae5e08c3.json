{"ast":null,"code":"import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns } from \"./lexer\";\nimport { cloneArr, cloneObj, forEach, IDENTITY, isArray, isEmpty, isUndefined, keys, last, map, merge, NOOP, PRINT_WARNING, reduce, reject, timer, toFastProperties } from \"../utils/utils\";\nimport { augmentTokenTypes } from \"./tokens\";\nimport { defaultLexerErrorProvider } from \"../scan/lexer_errors_public\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser\";\nexport var LexerDefinitionErrorType;\n\n(function (LexerDefinitionErrorType) {\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\n\nvar DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\n\nvar Lexer =\n/** @class */\nfunction () {\n  function Lexer(lexerDefinition, config) {\n    var _this = this;\n\n    if (config === void 0) {\n      config = DEFAULT_LEXER_CONFIG;\n    }\n\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.config = undefined;\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {};\n\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" + \"a boolean 2nd argument is no longer supported\");\n    } // todo: defaults func?\n\n\n    this.config = merge(DEFAULT_LEXER_CONFIG, config);\n    var traceInitVal = this.config.traceInitPerf;\n\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", function () {\n      var actualDefinition;\n      var hasOnlySingleMode = true;\n\n      _this.TRACE_INIT(\"Lexer Config handling\", function () {\n        if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          _this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n        } else {\n          if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n\n        _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n        _this.trackEndLines = /full/i.test(_this.config.positionTracking); // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: {}\n          };\n          actualDefinition.modes[DEFAULT_MODE] = cloneArr(lexerDefinition);\n          actualDefinition[DEFAULT_MODE] = DEFAULT_MODE;\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false;\n          actualDefinition = cloneObj(lexerDefinition);\n        }\n      });\n\n      if (_this.config.skipValidations === false) {\n        _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n          _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n\n        _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n          _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n      } // for extra robustness to avoid throwing an none informative error message\n\n\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {}; // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n\n      forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n        actualDefinition.modes[currModeName] = reject(currModeValue, function (currTokType) {\n          return isUndefined(currTokType);\n        });\n      });\n      var allModeNames = keys(actualDefinition.modes);\n      forEach(actualDefinition.modes, function (currModDef, currModName) {\n        _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n          _this.modes.push(currModName);\n\n          if (_this.config.skipValidations === false) {\n            _this.TRACE_INIT(\"validatePatterns\", function () {\n              _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n            });\n          } // If definition errors were encountered, the analysis phase may fail unexpectedly/\n          // Considering a lexer with definition errors may never be used, there is no point\n          // to performing the analysis anyhow...\n\n\n          if (isEmpty(_this.lexerDefinitionErrors)) {\n            augmentTokenTypes(currModDef);\n            var currAnalyzeResult_1;\n\n            _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n              currAnalyzeResult_1 = analyzeTokenTypes(currModDef, {\n                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: _this.TRACE_INIT.bind(_this)\n              });\n            });\n\n            _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;\n            _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n            _this.emptyGroups = merge(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n            _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n            _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;\n          }\n        });\n      });\n      _this.defaultMode = actualDefinition.defaultMode;\n\n      if (!isEmpty(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {\n        var allErrMessages = map(_this.lexerDefinitionErrors, function (error) {\n          return error.message;\n        });\n        var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      } // Only print warning if there are no errors, This will avoid pl\n\n\n      forEach(_this.lexerDefinitionWarning, function (warningDescriptor) {\n        PRINT_WARNING(warningDescriptor.message);\n      });\n\n      _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          _this.chopInput = IDENTITY;\n          _this.match = _this.matchWithTest;\n        } else {\n          _this.updateLastIndex = NOOP;\n          _this.match = _this.matchWithExec;\n        }\n\n        if (hasOnlySingleMode) {\n          _this.handleModes = NOOP;\n        }\n\n        if (_this.trackStartLines === false) {\n          _this.computeNewColumn = IDENTITY;\n        }\n\n        if (_this.trackEndLines === false) {\n          _this.updateTokenEndLineColumnLocation = NOOP;\n        }\n\n        if (/full/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createFullToken;\n        } else if (/onlyStart/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createOffsetOnlyToken;\n        } else {\n          throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n        }\n\n        if (_this.hasCustom) {\n          _this.addToken = _this.addTokenUsingPush;\n          _this.handlePayload = _this.handlePayloadWithCustom;\n        } else {\n          _this.addToken = _this.addTokenUsingMemberAccess;\n          _this.handlePayload = _this.handlePayloadNoCustom;\n        }\n      });\n\n      _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n        var unOptimizedModes = reduce(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n\n          return cannotBeOptimized;\n        }, []);\n\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" + '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' + \"\\t Or inspect the console log for details on how to resolve these issues.\");\n        }\n      });\n\n      _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n        clearRegExpParserCache();\n      });\n\n      _this.TRACE_INIT(\"toFastProperties\", function () {\n        toFastProperties(_this);\n      });\n    });\n  }\n\n  Lexer.prototype.tokenize = function (text, initialMode) {\n    if (initialMode === void 0) {\n      initialMode = this.defaultMode;\n    }\n\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      var allErrMessages = map(this.lexerDefinitionErrors, function (error) {\n        return error.message;\n      });\n      var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n\n    var lexResult = this.tokenizeInternal(text, initialMode);\n    return lexResult;\n  }; // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n\n\n  Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n    var _this = this;\n\n    var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n    var orgText = text;\n    var orgLength = orgText.length;\n    var offset = 0;\n    var matchedTokensIndex = 0; // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n\n    var guessedNumberOfTokens = this.hasCustom ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n    : Math.floor(text.length / 10);\n    var matchedTokens = new Array(guessedNumberOfTokens);\n    var errors = [];\n    var line = this.trackStartLines ? 1 : undefined;\n    var column = this.trackStartLines ? 1 : undefined;\n    var groups = cloneEmptyGroups(this.emptyGroups);\n    var trackLines = this.trackStartLines;\n    var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    var currModePatternsLength = 0;\n    var patternIdxToConfig = [];\n    var currCharCodeToPatternIdxToConfig = [];\n    var modeStack = [];\n    var emptyArray = [];\n    Object.freeze(emptyArray);\n    var getPossiblePatterns = undefined;\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n\n    function getPossiblePatternsOptimized(charCode) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n      var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n\n      if (possiblePatterns === undefined) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n\n    var pop_mode = function pop_mode(popToken) {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === undefined) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine !== undefined ? popToken.startLine : undefined,\n          column: popToken.startColumn !== undefined ? popToken.startColumn : undefined,\n          length: popToken.image.length,\n          message: msg_1\n        });\n      } else {\n        modeStack.pop();\n        var newMode = last(modeStack);\n        patternIdxToConfig = _this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    } // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n\n\n    push_mode.call(this, initialMode);\n    var currConfig;\n\n    while (offset < orgLength) {\n      matchedImage = null;\n      var nextCharCode = orgText.charCodeAt(offset);\n      var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      var chosenPatternsLength = chosenPatternIdxToConfig.length;\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        var currPattern = currConfig.pattern;\n        payload = null; // manually in-lined because > 600 chars won't be in-lined in V8\n\n        var singleCharCode = currConfig.short;\n\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n\n          if (match !== null) {\n            matchedImage = match[0];\n\n            if (match.payload !== undefined) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAltIdx = currConfig.longerAlt;\n\n          if (longerAltIdx !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            var longerAltConfig = patternIdxToConfig[longerAltIdx];\n            var longerAltPattern = longerAltConfig.pattern;\n            altPayload = null; // single Char can never be a longer alt so no need to test it.\n            // manually in-lined because > 600 chars won't be in-lined in V8\n\n            if (longerAltConfig.isCustom === true) {\n              match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n\n              if (match !== null) {\n                matchAltImage = match[0];\n\n                if (match.payload !== undefined) {\n                  altPayload = match.payload;\n                }\n              } else {\n                matchAltImage = null;\n              }\n            } else {\n              this.updateLastIndex(longerAltPattern, offset);\n              matchAltImage = this.match(longerAltPattern, text, offset);\n            }\n\n            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n              matchedImage = matchAltImage;\n              payload = altPayload;\n              currConfig = longerAltConfig;\n            }\n          }\n\n          break;\n        }\n      } // successful match\n\n\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx; // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload); // TODO: optimize NOOP in case there are no special groups?\n\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength; // TODO: with newlines the column may be assigned twice\n\n        column = this.computeNewColumn(column, imageLength);\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          var numOfLTsInMatch = 0;\n          var foundTerminator = void 0;\n          var lastLTEndOffset = void 0;\n          lineTerminatorPattern.lastIndex = 0;\n\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        } // will be NOOP if no modes present\n\n\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        var errorStartOffset = offset;\n        var errorLine = line;\n        var errorColumn = column;\n        var foundResyncPoint = false;\n\n        while (!foundResyncPoint && offset < orgLength) {\n          // drop chars until we succeed in matching something\n          droppedChar = orgText.charCodeAt(offset); // Identity Func (when sticky flag is enabled)\n\n          text = this.chopInput(text, 1);\n          offset++;\n\n          for (j = 0; j < currModePatternsLength; j++) {\n            var currConfig_1 = patternIdxToConfig[j];\n            var currPattern = currConfig_1.pattern; // manually in-lined because > 600 chars won't be in-lined in V8\n\n            var singleCharCode = currConfig_1.short;\n\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true;\n              }\n            } else if (currConfig_1.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset; // at this point we either re-synced or reached the end of the input text\n\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n      }\n    } // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n\n\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex;\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    };\n  };\n\n  Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      var pushMode = config.push;\n      pop_mode(newToken);\n\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push);\n    }\n  };\n\n  Lexer.prototype.chopInput = function (text, length) {\n    return text.substring(length);\n  };\n\n  Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  }; // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n\n\n  Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    var lastCharIsLT, fixForEndingInLT;\n\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT; // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      } // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n\n    }\n  };\n\n  Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  }; // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n\n  /* istanbul ignore next - place holder */\n\n\n  Lexer.prototype.createTokenInstance = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return null;\n  };\n\n  Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n\n  Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      startLine: startLine,\n      startColumn: startColumn,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n\n  Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine: startLine,\n      endLine: startLine,\n      startColumn: startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  }; // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n\n  /* istanbul ignore next - place holder */\n\n\n  Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n    return 666;\n  };\n\n  Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  };\n\n  Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  }; // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n\n  /* istanbul ignore next - place holder */\n\n\n  Lexer.prototype.handlePayload = function (token, payload) {};\n\n  Lexer.prototype.handlePayloadNoCustom = function (token, payload) {};\n\n  Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  };\n  /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n\n\n  Lexer.prototype.match = function (pattern, text, offset) {\n    return null;\n  };\n\n  Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n    var found = pattern.test(text);\n\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n\n    return null;\n  };\n\n  Lexer.prototype.matchWithExec = function (pattern, text) {\n    var regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : regExpArray;\n  }; // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n\n\n  Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(indent + \"--> <\" + phaseDesc + \">\");\n      }\n\n      var _a = timer(phaseImpl),\n          time = _a.time,\n          value = _a.value;\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n\n\n      var traceMethod = time > 10 ? console.warn : console.log;\n\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n      }\n\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  };\n\n  Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" + \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n  Lexer.NA = /NOT_APPLICABLE/;\n  return Lexer;\n}();\n\nexport { Lexer };","map":{"version":3,"mappings":"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","names":["analyzeTokenTypes","charCodeToOptimizedIndex","cloneEmptyGroups","DEFAULT_MODE","LineTerminatorOptimizedTester","performRuntimeChecks","performWarningRuntimeChecks","SUPPORT_STICKY","validatePatterns","cloneArr","cloneObj","forEach","IDENTITY","isArray","isEmpty","isUndefined","keys","last","map","merge","NOOP","PRINT_WARNING","reduce","reject","timer","toFastProperties","augmentTokenTypes","defaultLexerErrorProvider","clearRegExpParserCache","LexerDefinitionErrorType","DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","positionTracking","lineTerminatorsPattern","lineTerminatorCharacters","ensureOptimizations","safeMode","errorMessageProvider","traceInitPerf","skipValidations","Object","freeze","lexerDefinition","config","undefined","Error","traceInitVal","traceInitMaxIdent","Infinity","traceInitIndent","TRACE_INIT","actualDefinition","hasOnlySingleMode","_this","trackStartLines","test","trackEndLines","modes","lexerDefinitionErrors","concat","lexerDefinitionWarning","currModeValue","currModeName","currTokType","allModeNames","currModDef","currModName","push","currAnalyzeResult_1","tracer","bind","patternIdxToConfig","charCodeToPatternIdxToConfig","emptyGroups","hasCustom","canModeBeOptimized","canBeOptimized","defaultMode","allErrMessages","error","message","allErrMessagesString","join","warningDescriptor","chopInput","match","matchWithTest","updateLastIndex","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","cannotBeOptimized","modeName","Lexer","text","initialMode","lexResult","tokenizeInternal","i","j","matchAltImage","longerAltIdx","matchedImage","payload","altPayload","imageLength","group","tokType","newToken","errLength","droppedChar","msg","orgText","orgLength","length","offset","matchedTokensIndex","guessedNumberOfTokens","Math","floor","matchedTokens","Array","errors","line","column","groups","trackLines","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","charCode","optimizedCharIdx","possiblePatterns","pop_mode","popToken","tokenType","PUSH_MODE","msg_1","buildUnableToPopLexerModeMessage","startOffset","startLine","startColumn","image","pop","newMode","modeCanBeOptimized","push_mode","call","currConfig","nextCharCode","charCodeAt","chosenPatternIdxToConfig","chosenPatternsLength","currPattern","pattern","singleCharCode","short","isCustom","exec","longerAlt","longerAltConfig","longerAltPattern","tokenTypeIdx","canLineTerminator","numOfLTsInMatch","foundTerminator","lastLTEndOffset","lastIndex","errorStartOffset","errorLine","errorColumn","foundResyncPoint","currConfig_1","buildUnexpectedCharactersMessage","tokens","pushMode","substring","regExp","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","endLine","endColumn","oldColumn","args","endOffset","tokenVector","index","tokenToAdd","token","found","regExpArray","phaseDesc","phaseImpl","indent","console","log","time","value","traceMethod","warn"],"sourceRoot":"","sources":["../../../src/scan/lexer_public.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}