{"ast":null,"code":"import { Vector3, Color, Vector2, Matrix3 } from 'three';\n\nvar OBJExporter = function OBJExporter() {};\n\nOBJExporter.prototype = {\n  constructor: OBJExporter,\n  parse: function parse(object) {\n    var output = '';\n    var indexVertex = 0;\n    var indexVertexUvs = 0;\n    var indexNormals = 0;\n    var vertex = new Vector3();\n    var color = new Color();\n    var normal = new Vector3();\n    var uv = new Vector2();\n    var i;\n    var j;\n    var k;\n    var l;\n    var m;\n    var face = [];\n\n    var parseMesh = function parseMesh(mesh) {\n      var nbVertex = 0;\n      var nbNormals = 0;\n      var nbVertexUvs = 0;\n      var geometry = mesh.geometry;\n      var normalMatrixWorld = new Matrix3();\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      var vertices = geometry.getAttribute('position');\n      var normals = geometry.getAttribute('normal');\n      var uvs = geometry.getAttribute('uv');\n      var indices = geometry.getIndex(); // name of the mesh object\n\n      output += \"o \".concat(mesh.name, \"\\n\"); // name of the mesh material\n\n      if (mesh.material && mesh.material.name) {\n        output += \"usemtl \".concat(mesh.material.name, \"\\n\");\n      } // vertices\n\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(mesh.matrixWorld); // transform the vertex to export format\n\n          output += \"v \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z, \"\\n\");\n        }\n      } // uvs\n\n\n      if (uvs !== undefined) {\n        for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n          uv.x = uvs.getX(i);\n          uv.y = uvs.getY(i); // transform the uv to export format\n\n          output += \"vt \".concat(uv.x, \" \").concat(uv.y, \"\\n\");\n        }\n      } // normals\n\n\n      if (normals !== undefined) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (i = 0, l = normals.count; i < l; i++, nbNormals++) {\n          normal.x = normals.getX(i);\n          normal.y = normals.getY(i);\n          normal.z = normals.getZ(i); // transform the normal to world space\n\n          normal.applyMatrix3(normalMatrixWorld).normalize(); // transform the normal to export format\n\n          output += \"vn \".concat(normal.x, \" \").concat(normal.y, \" \").concat(normal.z, \"\\n\");\n        }\n      } // faces\n\n\n      if (indices !== null) {\n        for (i = 0, l = indices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = indices.getX(i + m) + 1;\n            face[m] = indexVertex + j + (normals || uvs ? \"/\".concat(uvs ? indexVertexUvs + j : '').concat(normals ? \"/\".concat(indexNormals + j) : '') : '');\n          } // transform the face to export format\n\n\n          output += \"f \".concat(face.join(' '), \"\\n\");\n        }\n      } else {\n        for (i = 0, l = vertices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = i + m + 1;\n            face[m] = indexVertex + j + (normals || uvs ? \"/\".concat(uvs ? indexVertexUvs + j : '').concat(normals ? \"/\".concat(indexNormals + j) : '') : '');\n          } // transform the face to export format\n\n\n          output += \"f \".concat(face.join(' '), \"\\n\");\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n      indexVertexUvs += nbVertexUvs;\n      indexNormals += nbNormals;\n    };\n\n    var parseLine = function parseLine(line) {\n      var nbVertex = 0;\n      var geometry = line.geometry;\n      var type = line.type;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      var vertices = geometry.getAttribute('position'); // name of the line object\n\n      output += \"o \".concat(line.name, \"\\n\");\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(line.matrixWorld); // transform the vertex to export format\n\n          output += \"v \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z, \"\\n\");\n        }\n      }\n\n      if (type === 'Line') {\n        output += 'l ';\n\n        for (j = 1, l = vertices.count; j <= l; j++) {\n          output += \"\".concat(indexVertex + j, \" \");\n        }\n\n        output += '\\n';\n      }\n\n      if (type === 'LineSegments') {\n        for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n          output += \"l \".concat(indexVertex + j, \" \").concat(indexVertex + k, \"\\n\");\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n    };\n\n    var parsePoints = function parsePoints(points) {\n      var nbVertex = 0;\n      var geometry = points.geometry;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      var vertices = geometry.getAttribute('position');\n      var colors = geometry.getAttribute('color');\n      output += \"o \".concat(points.name, \"\\n\");\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.fromBufferAttribute(vertices, i);\n          vertex.applyMatrix4(points.matrixWorld);\n          output += \"v \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z);\n\n          if (colors !== undefined) {\n            color.fromBufferAttribute(colors, i);\n            output += \" \".concat(color.r, \" \").concat(color.g, \" \").concat(color.b);\n          }\n\n          output += '\\n';\n        }\n      }\n\n      output += 'p ';\n\n      for (j = 1, l = vertices.count; j <= l; j++) {\n        output += \"\".concat(indexVertex + j, \" \");\n      }\n\n      output += '\\n'; // update index\n\n      indexVertex += nbVertex;\n    };\n\n    object.traverse(function (child) {\n      if (child.isMesh === true) {\n        parseMesh(child);\n      }\n\n      if (child.isLine === true) {\n        parseLine(child);\n      }\n\n      if (child.isPoints === true) {\n        parsePoints(child);\n      }\n    });\n    return output;\n  }\n};\nexport { OBJExporter };","map":{"version":3,"names":["Vector3","Color","Vector2","Matrix3","OBJExporter","prototype","constructor","parse","object","output","indexVertex","indexVertexUvs","indexNormals","vertex","color","normal","uv","i","j","k","l","m","face","parseMesh","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","indices","getIndex","name","material","undefined","count","x","getX","y","getY","z","getZ","applyMatrix4","matrixWorld","getNormalMatrix","applyMatrix3","normalize","join","parseLine","line","type","parsePoints","points","colors","fromBufferAttribute","r","g","b","traverse","child","isMesh","isLine","isPoints"],"sources":["/Users/98yaroslavgorban/Desktop/gltfjsx-forked/node_modules/three-stdlib/exporters/OBJExporter.js"],"sourcesContent":["import { Vector3, Color, Vector2, Matrix3 } from 'three';\n\nconst OBJExporter = () => {};\n\nOBJExporter.prototype = {\n  constructor: OBJExporter,\n  parse: function (object) {\n    let output = '';\n    let indexVertex = 0;\n    let indexVertexUvs = 0;\n    let indexNormals = 0;\n    const vertex = new Vector3();\n    const color = new Color();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let i;\n    let j;\n    let k;\n    let l;\n    let m;\n    const face = [];\n\n    const parseMesh = mesh => {\n      let nbVertex = 0;\n      let nbNormals = 0;\n      let nbVertexUvs = 0;\n      const geometry = mesh.geometry;\n      const normalMatrixWorld = new Matrix3();\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      const vertices = geometry.getAttribute('position');\n      const normals = geometry.getAttribute('normal');\n      const uvs = geometry.getAttribute('uv');\n      const indices = geometry.getIndex(); // name of the mesh object\n\n      output += `o ${mesh.name}\\n`; // name of the mesh material\n\n      if (mesh.material && mesh.material.name) {\n        output += `usemtl ${mesh.material.name}\\n`;\n      } // vertices\n\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(mesh.matrixWorld); // transform the vertex to export format\n\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n        }\n      } // uvs\n\n\n      if (uvs !== undefined) {\n        for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n          uv.x = uvs.getX(i);\n          uv.y = uvs.getY(i); // transform the uv to export format\n\n          output += `vt ${uv.x} ${uv.y}\\n`;\n        }\n      } // normals\n\n\n      if (normals !== undefined) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (i = 0, l = normals.count; i < l; i++, nbNormals++) {\n          normal.x = normals.getX(i);\n          normal.y = normals.getY(i);\n          normal.z = normals.getZ(i); // transform the normal to world space\n\n          normal.applyMatrix3(normalMatrixWorld).normalize(); // transform the normal to export format\n\n          output += `vn ${normal.x} ${normal.y} ${normal.z}\\n`;\n        }\n      } // faces\n\n\n      if (indices !== null) {\n        for (i = 0, l = indices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = indices.getX(i + m) + 1;\n            face[m] = indexVertex + j + (normals || uvs ? `/${uvs ? indexVertexUvs + j : ''}${normals ? `/${indexNormals + j}` : ''}` : '');\n          } // transform the face to export format\n\n\n          output += `f ${face.join(' ')}\\n`;\n        }\n      } else {\n        for (i = 0, l = vertices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = i + m + 1;\n            face[m] = indexVertex + j + (normals || uvs ? `/${uvs ? indexVertexUvs + j : ''}${normals ? `/${indexNormals + j}` : ''}` : '');\n          } // transform the face to export format\n\n\n          output += `f ${face.join(' ')}\\n`;\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n      indexVertexUvs += nbVertexUvs;\n      indexNormals += nbNormals;\n    };\n\n    const parseLine = line => {\n      let nbVertex = 0;\n      const geometry = line.geometry;\n      const type = line.type;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      const vertices = geometry.getAttribute('position'); // name of the line object\n\n      output += `o ${line.name}\\n`;\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(line.matrixWorld); // transform the vertex to export format\n\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n        }\n      }\n\n      if (type === 'Line') {\n        output += 'l ';\n\n        for (j = 1, l = vertices.count; j <= l; j++) {\n          output += `${indexVertex + j} `;\n        }\n\n        output += '\\n';\n      }\n\n      if (type === 'LineSegments') {\n        for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n          output += `l ${indexVertex + j} ${indexVertex + k}\\n`;\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n    };\n\n    const parsePoints = points => {\n      let nbVertex = 0;\n      const geometry = points.geometry;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      const vertices = geometry.getAttribute('position');\n      const colors = geometry.getAttribute('color');\n      output += `o ${points.name}\\n`;\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.fromBufferAttribute(vertices, i);\n          vertex.applyMatrix4(points.matrixWorld);\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}`;\n\n          if (colors !== undefined) {\n            color.fromBufferAttribute(colors, i);\n            output += ` ${color.r} ${color.g} ${color.b}`;\n          }\n\n          output += '\\n';\n        }\n      }\n\n      output += 'p ';\n\n      for (j = 1, l = vertices.count; j <= l; j++) {\n        output += `${indexVertex + j} `;\n      }\n\n      output += '\\n'; // update index\n\n      indexVertex += nbVertex;\n    };\n\n    object.traverse(child => {\n      if (child.isMesh === true) {\n        parseMesh(child);\n      }\n\n      if (child.isLine === true) {\n        parseLine(child);\n      }\n\n      if (child.isPoints === true) {\n        parsePoints(child);\n      }\n    });\n    return output;\n  }\n};\n\nexport { OBJExporter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}