{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { RestWalker } from \"./rest\";\nimport { cloneArr, drop, dropRight, first as _first, forEach, isEmpty, last } from \"../../utils/utils\";\nimport { first } from \"./first\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"./gast/gast_public\";\n\nvar AbstractNextPossibleTokensWalker =\n/** @class */\nfunction (_super) {\n  __extends(AbstractNextPossibleTokensWalker, _super);\n\n  function AbstractNextPossibleTokensWalker(topProd, path) {\n    var _this = _super.call(this) || this;\n\n    _this.topProd = topProd;\n    _this.path = path;\n    _this.possibleTokTypes = [];\n    _this.nextProductionName = \"\";\n    _this.nextProductionOccurrence = 0;\n    _this.found = false;\n    _this.isAtEndOfPath = false;\n    return _this;\n  }\n\n  AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n    this.found = false;\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    } // immutable for the win\n\n\n    this.ruleStack = cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\n\n    this.occurrenceStack = cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n    // already verified that the first production is valid, we now seek the 2nd production\n\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n    if (prevRest === void 0) {\n      prevRest = [];\n    } // stop scanning once we found the path\n\n\n    if (!this.found) {\n      _super.prototype.walk.call(this, prod, prevRest);\n    }\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n    // found the next production, need to keep walking in it\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      var fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  };\n\n  return AbstractNextPossibleTokensWalker;\n}(RestWalker);\n\nexport { AbstractNextPossibleTokensWalker };\n\nvar NextAfterTokenWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextAfterTokenWalker, _super);\n\n  function NextAfterTokenWalker(topProd, path) {\n    var _this = _super.call(this, topProd, path) || this;\n\n    _this.path = path;\n    _this.nextTerminalName = \"\";\n    _this.nextTerminalOccurrence = 0;\n    _this.nextTerminalName = _this.path.lastTok.name;\n    _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n    return _this;\n  }\n\n  NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      var fullRest = currRest.concat(prevRest);\n      var restProd = new Alternative({\n        definition: fullRest\n      });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  };\n\n  return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker);\n\nexport { NextAfterTokenWalker };\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\n\nvar AbstractNextTerminalAfterProductionWalker =\n/** @class */\nfunction (_super) {\n  __extends(AbstractNextTerminalAfterProductionWalker, _super);\n\n  function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n    var _this = _super.call(this) || this;\n\n    _this.topRule = topRule;\n    _this.occurrence = occurrence;\n    _this.result = {\n      token: undefined,\n      occurrence: undefined,\n      isEndOfRule: undefined\n    };\n    return _this;\n  }\n\n  AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n    this.walk(this.topRule);\n    return this.result;\n  };\n\n  return AbstractNextTerminalAfterProductionWalker;\n}(RestWalker);\n\nexport { AbstractNextTerminalAfterProductionWalker };\n\nvar NextTerminalAfterManyWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterManyWalker, _super);\n\n  function NextTerminalAfterManyWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      var firstAfterMany = _first(currRest.concat(prevRest));\n\n      this.result.isEndOfRule = firstAfterMany === undefined;\n\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexport { NextTerminalAfterManyWalker };\n\nvar NextTerminalAfterManySepWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterManySepWalker, _super);\n\n  function NextTerminalAfterManySepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      var firstAfterManySep = _first(currRest.concat(prevRest));\n\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexport { NextTerminalAfterManySepWalker };\n\nvar NextTerminalAfterAtLeastOneWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterAtLeastOneWalker, _super);\n\n  function NextTerminalAfterAtLeastOneWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      var firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexport { NextTerminalAfterAtLeastOneWalker }; // TODO: reduce code duplication in the AfterWalkers\n\nvar NextTerminalAfterAtLeastOneSepWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n\n  function NextTerminalAfterAtLeastOneSepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      var firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexport { NextTerminalAfterAtLeastOneSepWalker };\nexport function possiblePathsFrom(targetDef, maxLength, currPath) {\n  if (currPath === void 0) {\n    currPath = [];\n  } // avoid side effects\n\n\n  currPath = cloneArr(currPath);\n  var result = [];\n  var i = 0; // TODO: avoid inner funcs\n\n  function remainingPathWith(nextDef) {\n    return nextDef.concat(drop(targetDef, i + 1));\n  } // TODO: avoid inner funcs\n\n\n  function getAlternativesForProd(definition) {\n    var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n\n\n  while (currPath.length < maxLength && i < targetDef.length) {\n    var prod = targetDef[i];\n    /* istanbul ignore else */\n\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      var newDef = [new Alternative({\n        definition: prod.definition\n      }), new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, function (currAlt) {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n\n    i++;\n  }\n\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  });\n  return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\"; // to avoid creating a new Array each time.\n\n  var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  var foundCompletePath = false;\n  var tokenVectorLength = tokenVector.length;\n  var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  var result = [];\n  var possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n\n  while (!isEmpty(possiblePaths)) {\n    var currPath = possiblePaths.pop(); // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n\n      continue;\n    }\n\n    var currDef = currPath.def;\n    var currIdx = currPath.idx;\n    var currRuleStack = currPath.ruleStack;\n    var currOccurrenceStack = currPath.occurrenceStack; // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n\n    if (isEmpty(currDef)) {\n      continue;\n    }\n\n    var prod = currDef[0];\n    /* istanbul ignore else */\n\n    if (prod === EXIT_NON_TERMINAL) {\n      var nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        var nextIdx = currIdx + 1;\n        var actualToken = tokenVector[nextIdx];\n\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          var nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        } // end of the line\n\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      var newRuleStack = cloneArr(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      var newOccurrenceStack = cloneArr(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      var nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      var secondIteration = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      var nthRepetition = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE); // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n\n      var nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (var i = prod.definition.length - 1; i >= 0; i--) {\n        var currAlt = prod.definition[i];\n        var currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n\n  return result;\n}\n\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  var newRuleStack = cloneArr(currRuleStack);\n  newRuleStack.push(topRule.name);\n  var newCurrOccurrenceStack = cloneArr(currOccurrenceStack); // top rule is always assumed to have been called with occurrence index 1\n\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}","map":{"version":3,"mappings":"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","names":["RestWalker","cloneArr","drop","dropRight","first","_first","forEach","isEmpty","last","Alternation","Alternative","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Rule","Terminal","__extends","topProd","path","_super","_this","AbstractNextPossibleTokensWalker","found","ruleStack","name","Error","reverse","occurrenceStack","pop","updateExpectedNext","walk","possibleTokTypes","prod","prevRest","call","refProd","currRest","referencedRule","nextProductionName","idx","nextProductionOccurrence","fullRest","concat","isAtEndOfPath","nextTerminalName","lastTok","nextTerminalOccurrence","lastTokOccurrence","NextAfterTokenWalker","terminal","terminalType","restProd","definition","topRule","occurrence","token","undefined","isEndOfRule","AbstractNextTerminalAfterProductionWalker","result","NextTerminalAfterManyWalker","manyProd","firstAfterMany","walkMany","NextTerminalAfterManySepWalker","manySepProd","firstAfterManySep","walkManySep","NextTerminalAfterAtLeastOneWalker","atLeastOneProd","firstAfterAtLeastOne","walkAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","walkAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","currPath","i","remainingPathWith","nextDef","getAlternativesForProd","alternatives","length","newDef","separator","currAlt","push","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokenVector","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currIdx","currRuleStack","currOccurrenceStack","nextPath","nextIdx","actualToken","nextTokenType","nextTokenOccurrence","newRuleStack","nonTerminalName","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack"],"sourceRoot":"","sources":["../../../../src/parse/grammar/interpreter.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}