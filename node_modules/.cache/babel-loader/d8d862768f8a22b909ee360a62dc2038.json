{"ast":null,"code":"import { TempNode } from './TempNode.js';\nimport { NodeLib } from './NodeLib.js';\nvar declarationRegexp = /^\\s*([a-z_0-9]+)\\s([a-z_0-9]+)\\s*\\((.*?)\\)/i,\n    propertiesRegexp = /[a-z_0-9]+/gi;\n\nfunction FunctionNode(src, includes, extensions, keywords, type) {\n  this.isMethod = type === undefined;\n  this.isInterface = false;\n  TempNode.call(this, type);\n  this.parse(src, includes, extensions, keywords);\n}\n\nFunctionNode.prototype = Object.create(TempNode.prototype);\nFunctionNode.prototype.constructor = FunctionNode;\nFunctionNode.prototype.nodeType = 'Function';\nFunctionNode.prototype.useKeywords = true;\n\nFunctionNode.prototype.getShared = function ()\n/* builder, output */\n{\n  return !this.isMethod;\n};\n\nFunctionNode.prototype.getType = function (builder) {\n  return builder.getTypeByFormat(this.type);\n};\n\nFunctionNode.prototype.getInputByName = function (name) {\n  var i = this.inputs.length;\n\n  while (i--) {\n    if (this.inputs[i].name === name) {\n      return this.inputs[i];\n    }\n  }\n};\n\nFunctionNode.prototype.getIncludeByName = function (name) {\n  var i = this.includes.length;\n\n  while (i--) {\n    if (this.includes[i].name === name) {\n      return this.includes[i];\n    }\n  }\n};\n\nFunctionNode.prototype.generate = function (builder, output) {\n  var match,\n      offset = 0,\n      src = this.src;\n\n  for (var i = 0; i < this.includes.length; i++) {\n    builder.include(this.includes[i], this);\n  }\n\n  for (var ext in this.extensions) {\n    builder.extensions[ext] = true;\n  }\n\n  var matches = [];\n\n  while (match = propertiesRegexp.exec(this.src)) {\n    matches.push(match);\n  }\n\n  for (var _i = 0; _i < matches.length; _i++) {\n    var match = matches[_i];\n    var prop = match[0],\n        isGlobal = this.isMethod ? !this.getInputByName(prop) : true,\n        reference = prop;\n\n    if (this.keywords[prop] || this.useKeywords && isGlobal && NodeLib.containsKeyword(prop)) {\n      var node = this.keywords[prop];\n\n      if (!node) {\n        var keyword = NodeLib.getKeywordData(prop);\n        if (keyword.cache) node = builder.keywords[prop];\n        node = node || NodeLib.getKeyword(prop, builder);\n        if (keyword.cache) builder.keywords[prop] = node;\n      }\n\n      reference = node.build(builder);\n    }\n\n    if (prop !== reference) {\n      src = src.substring(0, match.index + offset) + reference + src.substring(match.index + prop.length + offset);\n      offset += reference.length - prop.length;\n    }\n\n    if (this.getIncludeByName(reference) === undefined && NodeLib.contains(reference)) {\n      builder.include(NodeLib.get(reference));\n    }\n  }\n\n  if (output === 'source') {\n    return src;\n  } else if (this.isMethod) {\n    if (!this.isInterface) {\n      builder.include(this, false, src);\n    }\n\n    return this.name;\n  } else {\n    return builder.format('( ' + src + ' )', this.getType(builder), output);\n  }\n};\n\nFunctionNode.prototype.parse = function (src, includes, extensions, keywords) {\n  this.src = src || '';\n  this.includes = includes || [];\n  this.extensions = extensions || {};\n  this.keywords = keywords || {};\n\n  if (this.isMethod) {\n    var match = this.src.match(declarationRegexp);\n    this.inputs = [];\n\n    if (match && match.length == 4) {\n      this.type = match[1];\n      this.name = match[2];\n      var inputs = match[3].match(propertiesRegexp);\n\n      if (inputs) {\n        var i = 0;\n\n        while (i < inputs.length) {\n          var qualifier = inputs[i++];\n          var type, name;\n\n          if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n            type = inputs[i++];\n          } else {\n            type = qualifier;\n            qualifier = '';\n          }\n\n          name = inputs[i++];\n          this.inputs.push({\n            name: name,\n            type: type,\n            qualifier: qualifier\n          });\n        }\n      }\n\n      this.isInterface = this.src.indexOf('{') === -1;\n    } else {\n      this.type = '';\n      this.name = '';\n    }\n  }\n};\n\nFunctionNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.isMethod = source.isMethod;\n  this.useKeywords = source.useKeywords;\n  this.parse(source.src, source.includes, source.extensions, source.keywords);\n  if (source.type !== undefined) this.type = source.type;\n  return this;\n};\n\nFunctionNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.src = this.src;\n    data.isMethod = this.isMethod;\n    data.useKeywords = this.useKeywords;\n    if (!this.isMethod) data.type = this.type;\n    data.extensions = JSON.parse(JSON.stringify(this.extensions));\n    data.keywords = {};\n\n    for (var keyword in this.keywords) {\n      data.keywords[keyword] = this.keywords[keyword].toJSON(meta).uuid;\n    }\n\n    if (this.includes.length) {\n      data.includes = [];\n\n      for (var i = 0; i < this.includes.length; i++) {\n        data.includes.push(this.includes[i].toJSON(meta).uuid);\n      }\n    }\n  }\n\n  return data;\n};\n\nexport { FunctionNode };","map":{"version":3,"names":["TempNode","NodeLib","declarationRegexp","propertiesRegexp","FunctionNode","src","includes","extensions","keywords","type","isMethod","undefined","isInterface","call","parse","prototype","Object","create","constructor","nodeType","useKeywords","getShared","getType","builder","getTypeByFormat","getInputByName","name","i","inputs","length","getIncludeByName","generate","output","match","offset","include","ext","matches","exec","push","prop","isGlobal","reference","containsKeyword","node","keyword","getKeywordData","cache","getKeyword","build","substring","index","contains","get","format","qualifier","indexOf","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","JSON","stringify","uuid"],"sources":["/Users/98yaroslavgorban/Desktop/gltfjsx-forked/node_modules/three-stdlib/nodes/core/FunctionNode.js"],"sourcesContent":["import { TempNode } from './TempNode.js';\nimport { NodeLib } from './NodeLib.js';\n\nvar declarationRegexp = /^\\s*([a-z_0-9]+)\\s([a-z_0-9]+)\\s*\\((.*?)\\)/i,\n    propertiesRegexp = /[a-z_0-9]+/gi;\n\nfunction FunctionNode(src, includes, extensions, keywords, type) {\n  this.isMethod = type === undefined;\n  this.isInterface = false;\n  TempNode.call(this, type);\n  this.parse(src, includes, extensions, keywords);\n}\n\nFunctionNode.prototype = Object.create(TempNode.prototype);\nFunctionNode.prototype.constructor = FunctionNode;\nFunctionNode.prototype.nodeType = 'Function';\nFunctionNode.prototype.useKeywords = true;\n\nFunctionNode.prototype.getShared = function ()\n/* builder, output */\n{\n  return !this.isMethod;\n};\n\nFunctionNode.prototype.getType = function (builder) {\n  return builder.getTypeByFormat(this.type);\n};\n\nFunctionNode.prototype.getInputByName = function (name) {\n  var i = this.inputs.length;\n\n  while (i--) {\n    if (this.inputs[i].name === name) {\n      return this.inputs[i];\n    }\n  }\n};\n\nFunctionNode.prototype.getIncludeByName = function (name) {\n  var i = this.includes.length;\n\n  while (i--) {\n    if (this.includes[i].name === name) {\n      return this.includes[i];\n    }\n  }\n};\n\nFunctionNode.prototype.generate = function (builder, output) {\n  var match,\n      offset = 0,\n      src = this.src;\n\n  for (let i = 0; i < this.includes.length; i++) {\n    builder.include(this.includes[i], this);\n  }\n\n  for (let ext in this.extensions) {\n    builder.extensions[ext] = true;\n  }\n\n  var matches = [];\n\n  while (match = propertiesRegexp.exec(this.src)) matches.push(match);\n\n  for (let i = 0; i < matches.length; i++) {\n    var match = matches[i];\n    var prop = match[0],\n        isGlobal = this.isMethod ? !this.getInputByName(prop) : true,\n        reference = prop;\n\n    if (this.keywords[prop] || this.useKeywords && isGlobal && NodeLib.containsKeyword(prop)) {\n      var node = this.keywords[prop];\n\n      if (!node) {\n        var keyword = NodeLib.getKeywordData(prop);\n        if (keyword.cache) node = builder.keywords[prop];\n        node = node || NodeLib.getKeyword(prop, builder);\n        if (keyword.cache) builder.keywords[prop] = node;\n      }\n\n      reference = node.build(builder);\n    }\n\n    if (prop !== reference) {\n      src = src.substring(0, match.index + offset) + reference + src.substring(match.index + prop.length + offset);\n      offset += reference.length - prop.length;\n    }\n\n    if (this.getIncludeByName(reference) === undefined && NodeLib.contains(reference)) {\n      builder.include(NodeLib.get(reference));\n    }\n  }\n\n  if (output === 'source') {\n    return src;\n  } else if (this.isMethod) {\n    if (!this.isInterface) {\n      builder.include(this, false, src);\n    }\n\n    return this.name;\n  } else {\n    return builder.format('( ' + src + ' )', this.getType(builder), output);\n  }\n};\n\nFunctionNode.prototype.parse = function (src, includes, extensions, keywords) {\n  this.src = src || '';\n  this.includes = includes || [];\n  this.extensions = extensions || {};\n  this.keywords = keywords || {};\n\n  if (this.isMethod) {\n    var match = this.src.match(declarationRegexp);\n    this.inputs = [];\n\n    if (match && match.length == 4) {\n      this.type = match[1];\n      this.name = match[2];\n      var inputs = match[3].match(propertiesRegexp);\n\n      if (inputs) {\n        var i = 0;\n\n        while (i < inputs.length) {\n          var qualifier = inputs[i++];\n          var type, name;\n\n          if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n            type = inputs[i++];\n          } else {\n            type = qualifier;\n            qualifier = '';\n          }\n\n          name = inputs[i++];\n          this.inputs.push({\n            name: name,\n            type: type,\n            qualifier: qualifier\n          });\n        }\n      }\n\n      this.isInterface = this.src.indexOf('{') === -1;\n    } else {\n      this.type = '';\n      this.name = '';\n    }\n  }\n};\n\nFunctionNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.isMethod = source.isMethod;\n  this.useKeywords = source.useKeywords;\n  this.parse(source.src, source.includes, source.extensions, source.keywords);\n  if (source.type !== undefined) this.type = source.type;\n  return this;\n};\n\nFunctionNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.src = this.src;\n    data.isMethod = this.isMethod;\n    data.useKeywords = this.useKeywords;\n    if (!this.isMethod) data.type = this.type;\n    data.extensions = JSON.parse(JSON.stringify(this.extensions));\n    data.keywords = {};\n\n    for (let keyword in this.keywords) {\n      data.keywords[keyword] = this.keywords[keyword].toJSON(meta).uuid;\n    }\n\n    if (this.includes.length) {\n      data.includes = [];\n\n      for (let i = 0; i < this.includes.length; i++) {\n        data.includes.push(this.includes[i].toJSON(meta).uuid);\n      }\n    }\n  }\n\n  return data;\n};\n\nexport { FunctionNode };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}