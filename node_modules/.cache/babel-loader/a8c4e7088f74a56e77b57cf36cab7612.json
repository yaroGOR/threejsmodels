{"ast":null,"code":"import { cloneArr, cloneObj, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values } from \"../../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../../grammar/keys\";\nimport { isRecognitionException, MismatchedTokenException, NotAllInputParsedException } from \"../../exceptions_public\";\nimport { PROD_TYPE } from \"../../grammar/lookahead\";\nimport { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker } from \"../../grammar/interpreter\";\nimport { DEFAULT_RULE_CONFIG } from \"../parser\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\";\nimport { EOF } from \"../../../scan/tokens_public\";\nimport { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../../scan/tokens\";\nimport { classNameFromInstance } from \"../../../lang/lang_extensions\";\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\n\nvar RecognizerEngine =\n/** @class */\nfunction () {\n  function RecognizerEngine() {}\n\n  RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n    this.className = classNameFromInstance(this); // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokenStructuredMatcherNoCategories;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" + \"\\tFor Further details.\");\n    }\n\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\" + \"\\tNote that the first argument for the parser constructor\\n\" + \"\\tis no longer a Token vector (since v4.0).\");\n      }\n\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" + \"\\tFor Further details.\");\n      }\n    }\n\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = reduce(tokenVocabulary, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (has(tokenVocabulary, \"modes\") && every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n      var allTokenTypes = flatten(values(tokenVocabulary.modes));\n      var uniqueTokens = uniq(allTokenTypes);\n      this.tokensMap = reduce(uniqueTokens, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = cloneObj(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" + \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    } // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n\n    /* tslint:disable */\n\n\n    this.tokensMap[\"EOF\"] = EOF; // TODO: This check may not be accurate for multi mode lexers\n\n    var noTokenCategoriesUsed = every(values(tokenVocabulary), function (tokenConstructor) {\n      return isEmpty(tokenConstructor.categoryMatches);\n    });\n    this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher; // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n\n    augmentTokenTypes(values(this.tokensMap));\n  };\n\n  RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" + \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n    }\n\n    var resyncEnabled = has(config, \"resyncEnabled\") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;\n    var recoveryValueFunc = has(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc; // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n\n    /* tslint:disable */\n\n    var shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;\n    /* tslint:enable */\n\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n\n    function invokeRuleWithTry(args) {\n      try {\n        if (this.outputCst === true) {\n          impl.apply(this, args);\n          var cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } else {\n          return impl.apply(this, args);\n        }\n      } catch (e) {\n        return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n      } finally {\n        this.ruleFinallyStateUpdate();\n      }\n    }\n\n    var wrappedGrammarRule;\n\n    wrappedGrammarRule = function wrappedGrammarRule(idxInCallingRule, args) {\n      if (idxInCallingRule === void 0) {\n        idxInCallingRule = 0;\n      }\n\n      this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n      return invokeRuleWithTry.call(this, args);\n    };\n\n    var ruleNamePropName = \"ruleName\";\n    wrappedGrammarRule[ruleNamePropName] = ruleName;\n    wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n    return wrappedGrammarRule;\n  };\n\n  RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n    var isFirstInvokedRule = this.RULE_STACK.length === 1; // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n\n    var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n\n    if (isRecognitionException(e)) {\n      var recogError = e;\n\n      if (reSyncEnabled) {\n        var reSyncTokType = this.findReSyncTokenType();\n\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc();\n          }\n        } else {\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          } // to be handled Further up the call stack\n\n\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState(); // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n\n        return recoveryValueFunc();\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  }; // Implementation of parsing DSL\n\n\n  RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n    var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  };\n\n  RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n    var _this = this;\n\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_1 = lookAheadFunc;\n\n        lookAheadFunc = function lookAheadFunc() {\n          return predicate.call(_this) && orgLookaheadFunction_1.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n\n    return undefined;\n  };\n\n  RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n\n  RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_2 = lookAheadFunc;\n\n        lookAheadFunc = function lookAheadFunc() {\n          return predicate.call(_this) && orgLookaheadFunction_2.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      var notStuck = this.doSingleRepetition(action);\n\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    } // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n  };\n\n  RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n\n  RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLookaheadFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;\n      action.call(this); //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n\n      var separatorLookAheadFunc = function separatorLookAheadFunc() {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  };\n\n  RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n\n  RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n\n    var lookaheadFunction = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_3 = lookaheadFunction;\n\n        lookaheadFunction = function lookaheadFunction() {\n          return predicate.call(_this) && orgLookaheadFunction_3.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    var notStuck = true;\n\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n    // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n    // An infinite loop cannot occur as:\n    // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n    // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n    notStuck);\n  };\n\n  RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n\n  RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLaFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n\n      var separatorLookAheadFunc = function separatorLookAheadFunc() {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator); // No need for checking infinite loop here due to consuming the separator.\n\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterManySepWalker], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n    }\n  };\n\n  RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    } // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n    /* istanbul ignore else */\n\n\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  };\n\n  RecognizerEngine.prototype.doSingleRepetition = function (action) {\n    var beforeIteration = this.getLexerPosition();\n    action.call(this);\n    var afterIteration = this.getLexerPosition(); // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n\n    return afterIteration > beforeIteration;\n  };\n\n  RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n    var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    var alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    var laFunc = this.getLaFuncFromCache(laKey);\n    var altIdxToTake = laFunc.call(this, alts);\n\n    if (altIdxToTake !== undefined) {\n      var chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  };\n\n  RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop(); // NOOP when cst is disabled\n\n    this.cstFinallyStateUpdate();\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      var firstRedundantTok = this.LA(1);\n      var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  };\n\n  RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n    var ruleResult;\n\n    try {\n      var args = options !== undefined ? options.ARGS : undefined;\n      ruleResult = ruleToCall.call(this, idx, args);\n      this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  };\n\n  RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n\n    throw e;\n  };\n\n  RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n    var consumedToken;\n\n    try {\n      var nextToken = this.LA(1);\n\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n\n    this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  };\n\n  RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n    var msg;\n    var previousToken = this.LA(0);\n\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n\n    throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n  };\n\n  RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  };\n\n  RecognizerEngine.prototype.saveRecogState = function () {\n    // errors is a getter which will clone the errors array\n    var savedErrors = this.errors;\n    var savedRuleStack = cloneArr(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    };\n  };\n\n  RecognizerEngine.prototype.reloadRecogState = function (newState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  };\n\n  RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName); // NOOP when cst is disabled\n\n    this.cstInvocationStateUpdate(fullName, shortName);\n  };\n\n  RecognizerEngine.prototype.isBackTracking = function () {\n    return this.isBackTrackingStack.length !== 0;\n  };\n\n  RecognizerEngine.prototype.getCurrRuleFullName = function () {\n    var shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  };\n\n  RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n    return this.shortRuleNameToFull[shortName];\n  };\n\n  RecognizerEngine.prototype.isAtEndOfInput = function () {\n    return this.tokenMatcher(this.LA(1), EOF);\n  };\n\n  RecognizerEngine.prototype.reset = function () {\n    this.resetLexerState();\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = []; // TODO: extract a specific reset for TreeBuilder trait\n\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  };\n\n  return RecognizerEngine;\n}();\n\nexport { RecognizerEngine };","map":{"version":3,"mappings":"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","names":["cloneArr","cloneObj","every","flatten","has","isArray","isEmpty","isObject","reduce","uniq","values","AT_LEAST_ONE_IDX","AT_LEAST_ONE_SEP_IDX","BITS_FOR_METHOD_TYPE","BITS_FOR_OCCURRENCE_IDX","MANY_IDX","MANY_SEP_IDX","OPTION_IDX","OR_IDX","isRecognitionException","MismatchedTokenException","NotAllInputParsedException","PROD_TYPE","NextTerminalAfterAtLeastOneSepWalker","NextTerminalAfterAtLeastOneWalker","NextTerminalAfterManySepWalker","NextTerminalAfterManyWalker","DEFAULT_RULE_CONFIG","IN_RULE_RECOVERY_EXCEPTION","EOF","augmentTokenTypes","isTokenType","tokenStructuredMatcher","tokenStructuredMatcherNoCategories","classNameFromInstance","RecognizerEngine","tokenVocabulary","config","className","shortRuleNameToFull","fullRuleNameToShort","ruleShortNameIdx","tokenMatcher","definedRulesNames","tokensMap","isBackTrackingStack","RULE_STACK","RULE_OCCURRENCE_STACK","gastProductionsCache","Error","startOffset","acc","tokType","name","modes","allTokenTypes","uniqueTokens","noTokenCategoriesUsed","tokenConstructor","categoryMatches","ruleName","impl","selfAnalysisDone","resyncEnabled","recoveryValueFunc","shortName","invokeRuleWithTry","args","outputCst","apply","cst","CST_STACK","length","cstPostRule","e","invokeRuleCatch","ruleFinallyStateUpdate","wrappedGrammarRule","idxInCallingRule","ruleInvocationStateUpdate","call","ruleNamePropName","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","isBackTracking","recoveryEnabled","recogError","reSyncTokType","findReSyncTokenType","isInCurrentRuleReSyncSet","resyncedTokens","reSyncTo","partialCstResult","recoveredNode","moveToTerminatedState","actionORMethodDef","occurrence","key","getKeyForAutomaticLookahead","optionInternalLogic","lookAheadFunc","getLaFuncFromCache","action","predicate","DEF","undefined","GATE","orgLookaheadFunction_1","_this","prodOccurrence","laKey","atLeastOneInternalLogic","orgLookaheadFunction_2","notStuck","doSingleRepetition","raiseEarlyExitException","REPETITION_MANDATORY","ERR_MSG","attemptInRepetitionRecovery","atLeastOneInternal","options","atLeastOneSepFirstInternalLogic","separator","SEP","firstIterationLookaheadFunc","separatorLookAheadFunc","LA","CONSUME","repetitionSepSecondInternal","REPETITION_MANDATORY_WITH_SEPARATOR","manyInternalLogic","lookaheadFunction","orgLookaheadFunction_3","manyInternal","manySepFirstInternalLogic","firstIterationLaFunc","nextTerminalAfterWalker","beforeIteration","getLexerPosition","afterIteration","altsOrOpts","alts","laFunc","altIdxToTake","chosenAlternative","ALT","raiseNoAltException","pop","cstFinallyStateUpdate","isAtEndOfInput","firstRedundantTok","errMsg","errorMessageProvider","buildNotAllInputParsedMessage","firstRedundant","getCurrRuleFullName","SAVE_ERROR","ruleToCall","idx","ruleResult","ARGS","cstPostNonTerminal","LABEL","subruleInternalError","consumedToken","nextToken","consumeToken","consumeInternalError","eFromConsumption","consumeInternalRecovery","cstPostTerminal","msg","previousToken","buildMismatchTokenMessage","expected","actual","previous","follows","getFollowsForInRuleRecovery","tryInRuleRecovery","eFromInRuleRecovery","savedErrors","errors","savedRuleStack","lexerState","exportLexerState","newState","importLexerState","fullName","push","cstInvocationStateUpdate","getLastExplicitRuleShortName","resetLexerState"],"sourceRoot":"","sources":["../../../../../src/parse/parser/traits/recognizer_engine.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}